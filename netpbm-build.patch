--- netpbm-10.35.65/converter/ppm/ppmtompeg/jpeg.c~	2006-08-19 05:12:28.000000000 +0200
+++ netpbm-10.35.65/converter/ppm/ppmtompeg/jpeg.c	2009-07-15 08:52:06.372101451 +0200
@@ -469,7 +469,7 @@
 #ifdef JPEG4
     buffer_height = 8;  /* could be 2, 4,8 rows high */
 #else
-    buffer_height = cinfo.max_v_samp_factor * cinfo.min_DCT_scaled_size;
+    buffer_height = cinfo.max_v_samp_factor * cinfo.min_DCT_v_scaled_size;
 #endif
   
     for(cp=0,compptr = cinfo.comp_info;cp<cinfo.num_components;
--- netpbm-10.35.83/converter/other/pnmtopng.c.orig	2011-09-25 20:51:44.000000000 +0200
+++ netpbm-10.35.83/converter/other/pnmtopng.c	2012-01-29 08:48:17.363289175 +0100
@@ -61,7 +61,8 @@
 #include <assert.h>
 #include <string.h> /* strcat() */
 #include <limits.h>
-#include <png.h>    /* includes zlib.h and setjmp.h */
+#include <png.h>    /* includes setjmp.h */
+#include <zlib.h>
 #include "pnm.h"
 #include "pngtxt.h"
 #include "shhopt.h"
@@ -69,11 +70,6 @@
 #include "nstring.h"
 #include "version.h"
 
-#if PNG_LIBPNG_VER >= 10400
-#error Your PNG library (<png.h>) is incompatible with this Netpbm source code.
-#error You need either an older PNG library (older than 1.4)
-#error newer Netpbm source code (at least 10.47.04)
-#endif
 
 
 struct zlibCompression {
@@ -2098,6 +2094,7 @@
             gray *               const alpha_mask,
             colorhash_table      const cht,
             coloralphahash_table const caht,
+	    png_struct *         const png_ptr,
             png_info *           const info_ptr,
             xelval               const png_maxval,
             unsigned int         const depth) {
@@ -2109,21 +2106,22 @@
     for (col = 0; col < cols; ++col) {
         xel p_png;
         xel const p = xelrow[col];
+	png_byte color_type = png_get_color_type(png_ptr, info_ptr);
         PPM_DEPTH(p_png, p, maxval, png_maxval);
-        if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-            info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
+        if (color_type == PNG_COLOR_TYPE_GRAY ||
+            color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
             if (depth == 16)
                 *pp++ = PNM_GET1(p_png) >> 8;
             *pp++ = PNM_GET1(p_png) & 0xff;
-        } else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+        } else if (color_type == PNG_COLOR_TYPE_PALETTE) {
             unsigned int paletteIndex;
             if (alpha)
                 paletteIndex = lookupColorAlpha(caht, &p, &alpha_mask[col]);
             else
                 paletteIndex = ppm_lookupcolor(cht, &p);
             *pp++ = paletteIndex;
-        } else if (info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
-                   info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
+        } else if (color_type == PNG_COLOR_TYPE_RGB ||
+                   color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
             if (depth == 16)
                 *pp++ = PPM_GETR(p_png) >> 8;
             *pp++ = PPM_GETR(p_png) & 0xff;
@@ -2136,7 +2134,7 @@
         } else
             pm_error("INTERNAL ERROR: undefined color_type");
                 
-        if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA) {
+        if (color_type & PNG_COLOR_MASK_ALPHA) {
             int const png_alphaval = (int)
                 alpha_mask[col] * (float) png_maxval / maxval + 0.5;
             if (depth == 16)
@@ -2193,7 +2191,7 @@
             
             makePngLine(line, xelrow, cols, maxval,
                         alpha, alpha ? alpha_mask[row] : NULL,
-                        cht, caht, info_ptr, png_maxval, depth);
+                        cht, caht, png_ptr, info_ptr, png_maxval, depth);
 
             png_write_row(png_ptr, line);
         }
@@ -2205,12 +2203,12 @@
 
 static void
 doGamaChunk(struct cmdlineInfo const cmdline,
+            png_struct *       const png_ptr,
             png_info *         const info_ptr) {
             
     if (cmdline.gammaSpec) {
         /* gAMA chunk */
-        info_ptr->valid |= PNG_INFO_gAMA;
-        info_ptr->gamma = cmdline.gamma;
+        png_set_gAMA(png_ptr, info_ptr, cmdline.gamma);	   
     }
 }
 
@@ -2218,20 +2216,16 @@
 
 static void
 doChrmChunk(struct cmdlineInfo const cmdline,
+            png_struct *       const png_ptr,
             png_info *         const info_ptr) {
 
     if (cmdline.rgbSpec) {
         /* cHRM chunk */
-        info_ptr->valid |= PNG_INFO_cHRM;
-
-        info_ptr->x_white = cmdline.rgb.wx;
-        info_ptr->y_white = cmdline.rgb.wy;
-        info_ptr->x_red   = cmdline.rgb.rx;
-        info_ptr->y_red   = cmdline.rgb.ry;
-        info_ptr->x_green = cmdline.rgb.gx;
-        info_ptr->y_green = cmdline.rgb.gy;
-        info_ptr->x_blue  = cmdline.rgb.bx;
-        info_ptr->y_blue  = cmdline.rgb.by;
+        png_set_cHRM(png_ptr, info_ptr,
+                     cmdline.rgb.wx, cmdline.rgb.wy,
+                     cmdline.rgb.rx, cmdline.rgb.ry,
+                     cmdline.rgb.gx, cmdline.rgb.gy,
+                     cmdline.rgb.bx, cmdline.rgb.by);
     }
 }
 
@@ -2239,15 +2233,13 @@
 
 static void
 doPhysChunk(struct cmdlineInfo const cmdline,
+            png_struct *       const png_ptr,
             png_info *         const info_ptr) {
 
     if (cmdline.sizeSpec) {
         /* pHYS chunk */
-        info_ptr->valid |= PNG_INFO_pHYs;
-
-        info_ptr->x_pixels_per_unit = cmdline.size.x;
-        info_ptr->y_pixels_per_unit = cmdline.size.y;
-        info_ptr->phys_unit_type    = cmdline.size.unit;
+        png_set_pHYs(png_ptr, info_ptr,
+                     cmdline.size.x, cmdline.size.y, cmdline.size.unit);
     }
 }
 
@@ -2256,26 +2248,29 @@
 
 static void
 doTimeChunk(struct cmdlineInfo const cmdline,
+            png_struct *       const png_ptr,
             png_info *         const info_ptr) {
 
     if (cmdline.modtimeSpec) {
         /* tIME chunk */
-        info_ptr->valid |= PNG_INFO_tIME;
-
-        png_convert_from_time_t(&info_ptr->mod_time, cmdline.modtime);
+        png_time ptime;
+        png_convert_from_time_t(&ptime, cmdline.modtime);
+	png_set_tIME(png_ptr, info_ptr, &ptime);
     }
 }
 
 
 
 static void
-doSbitChunk(png_info * const pngInfoP,
+doSbitChunk(png_struct * const png_ptr,
+            png_info * const pngInfoP,
             xelval     const pngMaxval,
             xelval     const maxval,
             bool       const alpha,
             xelval     const alphaMaxval) {
 
-    if (pngInfoP->color_type != PNG_COLOR_TYPE_PALETTE &&
+    png_byte color_type = png_get_color_type(png_ptr, pngInfoP);
+    if (color_type != PNG_COLOR_TYPE_PALETTE &&
         (pngMaxval > maxval || (alpha && pngMaxval > alphaMaxval))) {
 
         /* We're writing in a bit depth that doesn't match the maxval
@@ -2294,27 +2289,27 @@
            sBIT chunk.
         */
 
-        pngInfoP->valid |= PNG_INFO_sBIT;
-
+        png_color_8 sbit;
         {
             int const sbitval = pm_maxvaltobits(MIN(maxval, pngMaxval));
 
-            if (pngInfoP->color_type & PNG_COLOR_MASK_COLOR) {
-                pngInfoP->sig_bit.red   = sbitval;
-                pngInfoP->sig_bit.green = sbitval;
-                pngInfoP->sig_bit.blue  = sbitval;
+            if (color_type & PNG_COLOR_MASK_COLOR) {
+                sbit.red   = sbitval;
+                sbit.green = sbitval;
+                sbit.blue  = sbitval;
             } else
-                pngInfoP->sig_bit.gray = sbitval;
+                sbit.gray = sbitval;
             
             if (verbose)
                 pm_message("Writing sBIT chunk with bits = %d", sbitval);
         }
-        if (pngInfoP->color_type & PNG_COLOR_MASK_ALPHA) {
-            pngInfoP->sig_bit.alpha =
+        if (color_type & PNG_COLOR_MASK_ALPHA) {
+            sbit.alpha =
                 pm_maxvaltobits(MIN(alphaMaxval, pngMaxval));
             if (verbose)
-                pm_message("  alpha bits = %d", pngInfoP->sig_bit.alpha);
+                pm_message("  alpha bits = %d", sbit.alpha);
         }
+	png_set_sBIT(png_ptr, pngInfoP, &sbit);
     }
 }
 
@@ -2595,43 +2590,41 @@
     pm_error ("setjmp returns error condition (2)");
   }
 
-  png_init_io (png_ptr, stdout);
-  info_ptr->width = cols;
-  info_ptr->height = rows;
-  info_ptr->bit_depth = depth;
-
+  {
+  int color_type;
   if (colorMapped)
-    info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
+    color_type = PNG_COLOR_TYPE_PALETTE;
   else if (pnm_type == PPM_TYPE)
-    info_ptr->color_type = PNG_COLOR_TYPE_RGB;
+    color_type = PNG_COLOR_TYPE_RGB;
   else
-    info_ptr->color_type = PNG_COLOR_TYPE_GRAY;
+    color_type = PNG_COLOR_TYPE_GRAY;
 
-  if (alpha && info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
-    info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
+  if (alpha && (color_type != PNG_COLOR_TYPE_PALETTE))
+    color_type |= PNG_COLOR_MASK_ALPHA;
 
-  info_ptr->interlace_type = cmdline.interlace;
+  png_set_IHDR(png_ptr, info_ptr,
+               cols, rows, depth, color_type, 0, 0, 0);
+  }
 
-  doGamaChunk(cmdline, info_ptr);
+  if(cmdline.interlace)
+    png_set_interlace_handling(png_ptr);
 
-  doChrmChunk(cmdline, info_ptr);
+  doGamaChunk(cmdline, png_ptr, info_ptr);
 
-  doPhysChunk(cmdline, info_ptr);
+  doChrmChunk(cmdline, png_ptr, info_ptr);
 
-  if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+  doPhysChunk(cmdline, png_ptr, info_ptr);
+
+  if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE) {
 
     /* creating PNG palette  (PLTE and tRNS chunks) */
 
     createPngPalette(palette_pnm, palette_size, maxval,
                      trans_pnm, trans_size, alpha_maxval, 
                      palette, trans);
-    info_ptr->valid |= PNG_INFO_PLTE;
-    info_ptr->palette = palette;
-    info_ptr->num_palette = palette_size;
+    png_set_PLTE(png_ptr, info_ptr, palette, palette_size);
     if (trans_size > 0) {
-        info_ptr->valid |= PNG_INFO_tRNS;
-        info_ptr->trans = trans;
-        info_ptr->num_trans = trans_size;   /* omit opaque values */
+        png_set_tRNS(png_ptr, info_ptr, trans, trans_size, NULL);
     }
     /* creating hIST chunk */
     if (cmdline.hist) {
@@ -2657,18 +2650,17 @@
 
         ppm_freecolorhash(cht);
 
-        info_ptr->valid |= PNG_INFO_hIST;
-        info_ptr->hist = histogram;
+	png_set_hIST(png_ptr, info_ptr, histogram);
         if (verbose)
             pm_message("histogram created");
     }
   } else { /* color_type != PNG_COLOR_TYPE_PALETTE */
-    if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-        info_ptr->color_type == PNG_COLOR_TYPE_RGB) {
+    png_byte color_type = png_get_color_type(png_ptr, info_ptr);
+    if (color_type == PNG_COLOR_TYPE_GRAY ||
+        color_type == PNG_COLOR_TYPE_RGB) {
         if (transparent > 0) {
-            info_ptr->valid |= PNG_INFO_tRNS;
-            info_ptr->trans_values = 
-                xelToPngColor_16(transcolor, maxval, png_maxval);
+            png_color_16 c = xelToPngColor_16(transcolor, maxval, png_maxval);
+	    png_set_tRNS(png_ptr, info_ptr, NULL, 0, &c);
         }
     } else {
         /* This is PNG_COLOR_MASK_ALPHA.  Transparency will be handled
@@ -2676,60 +2668,58 @@
         */
     }
     if (verbose) {
-        if (info_ptr->valid && PNG_INFO_tRNS) 
+        png_color_16p trans_colorp = NULL;
+        if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) {
+	    png_get_tRNS(png_ptr, info_ptr, NULL, NULL, &trans_colorp);
+	}
+	if(trans_colorp != NULL)
             pm_message("Transparent color {gray, red, green, blue} = "
                        "{%d, %d, %d, %d}",
-                       info_ptr->trans_values.gray,
-                       info_ptr->trans_values.red,
-                       info_ptr->trans_values.green,
-                       info_ptr->trans_values.blue);
-        else
+                       trans_colorp->gray,
+                       trans_colorp->red,
+                       trans_colorp->green,
+                       trans_colorp->blue);
+	else
             pm_message("No transparent color");
     }
   }
 
   /* bKGD chunk */
   if (cmdline.background) {
-      info_ptr->valid |= PNG_INFO_bKGD;
-      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
-          info_ptr->background.index = background_index;
+      png_color_16 bkgd;
+      if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE) {
+          bkgd.index = background_index;
       } else {
-          info_ptr->background = 
-              xelToPngColor_16(backcolor, maxval, png_maxval);
+	  bkgd = xelToPngColor_16(backcolor, maxval, png_maxval);
           if (verbose)
               pm_message("Writing bKGD chunk with background color "
                          " {gray, red, green, blue} = {%d, %d, %d, %d}",
-                         info_ptr->background.gray, 
-                         info_ptr->background.red, 
-                         info_ptr->background.green, 
-                         info_ptr->background.blue ); 
+                         bkgd.gray, 
+                         bkgd.red, 
+                         bkgd.green, 
+                         bkgd.blue ); 
       }
+      png_set_bKGD(png_ptr, info_ptr, &bkgd);
   }
 
-  doSbitChunk(info_ptr, png_maxval, maxval, alpha, alpha_maxval);
+  doSbitChunk(png_ptr, info_ptr, png_maxval, maxval, alpha, alpha_maxval);
 
   /* tEXT and zTXT chunks */
   if (cmdline.text || cmdline.ztxt)
-      pnmpng_read_text(info_ptr, tfp, !!cmdline.ztxt, cmdline.verbose);
+      pnmpng_read_text(png_ptr, info_ptr, tfp, !!cmdline.ztxt, cmdline.verbose);
 
-  doTimeChunk(cmdline, info_ptr);
+  doTimeChunk(cmdline, png_ptr, info_ptr);
 
   if (cmdline.filterSet != 0)
       png_set_filter(png_ptr, 0, cmdline.filterSet);
 
   setZlibCompression(png_ptr, cmdline.zlibCompression);
 
+  png_init_io (png_ptr, stdout);
+
   /* write the png-info struct */
   png_write_info(png_ptr, info_ptr);
 
-  if (cmdline.text || cmdline.ztxt)
-      /* prevent from being written twice with png_write_end */
-      info_ptr->num_text = 0;
-
-  if (cmdline.modtime)
-      /* prevent from being written twice with png_write_end */
-      info_ptr->valid &= ~PNG_INFO_tIME;
-
   /* let libpng take care of, e.g., bit-depth conversions */
   png_set_packing (png_ptr);
 
--- netpbm-10.35.83/converter/other/pngtopnm.c.orig	2011-11-25 01:15:46.000000000 +0100
+++ netpbm-10.35.83/converter/other/pngtopnm.c	2012-01-29 13:39:20.230540563 +0100
@@ -44,11 +44,6 @@
 #include "nstring.h"
 #include "shhopt.h"
 
-#if PNG_LIBPNG_VER >= 10400
-#error Your PNG library (<png.h>) is incompatible with this Netpbm source code.
-#error You need either an older PNG library (older than 1.4)
-#error newer Netpbm source code (at least 10.48)
-#endif
 
 typedef struct _jmpbuf_wrapper {
   jmp_buf jmpbuf;
@@ -187,7 +182,7 @@
 
 
 
-#define get_png_val(p) _get_png_val (&(p), info_ptr->bit_depth)
+#define get_png_val(p) _get_png_val (&(p), bit_depth)
 
 static png_uint_16
 _get_png_val (png_byte ** const pp,
@@ -266,33 +261,37 @@
 }
 
 #ifdef __STDC__
-static void save_text (png_info *info_ptr, FILE *tfp)
+static void save_text (png_struct *png_ptr, png_info *info_ptr, FILE *tfp)
 #else
-static void save_text (info_ptr, tfp)
+static void save_text (png_ptr, info_ptr, tfp)
+png_struct *png_ptr;
 png_info *info_ptr;
 FILE *tfp;
 #endif
 {
   int i, j, k;
+  png_text *text;
+  int num_text;
+  png_get_text(png_ptr, info_ptr, &text, &num_text);
 
-  for (i = 0 ; i < info_ptr->num_text ; i++) {
+  for (i = 0 ; i < num_text ; i++) {
     j = 0;
-    while (info_ptr->text[i].key[j] != '\0' && info_ptr->text[i].key[j] != ' ')
+    while (text[i].key[j] != '\0' && text[i].key[j] != ' ')
       j++;    
-    if (info_ptr->text[i].key[j] != ' ') {
-      fprintf (tfp, "%s", info_ptr->text[i].key);
-      for (j = strlen (info_ptr->text[i].key) ; j < 15 ; j++)
+    if (text[i].key[j] != ' ') {
+      fprintf (tfp, "%s", text[i].key);
+      for (j = strlen (text[i].key) ; j < 15 ; j++)
         putc (' ', tfp);
     } else {
-      fprintf (tfp, "\"%s\"", info_ptr->text[i].key);
-      for (j = strlen (info_ptr->text[i].key) ; j < 13 ; j++)
+      fprintf (tfp, "\"%s\"", text[i].key);
+      for (j = strlen (text[i].key) ; j < 13 ; j++)
         putc (' ', tfp);
     }
     putc (' ', tfp); /* at least one space between key and text */
     
-    for (j = 0 ; j < info_ptr->text[i].text_length ; j++) {
-      putc (info_ptr->text[i].text[j], tfp);
-      if (info_ptr->text[i].text[j] == '\n')
+    for (j = 0 ; j < text[i].text_length ; j++) {
+      putc (text[i].text[j], tfp);
+      if (text[i].text[j] == '\n')
         for (k = 0 ; k < 16 ; k++)
           putc ((int)' ', tfp);
     }
@@ -301,9 +300,10 @@
 }
 
 #ifdef __STDC__
-static void show_time (png_info *info_ptr)
+static void show_time (png_struct *png_ptr, png_info *info_ptr)
 #else
-static void show_time (info_ptr)
+static void show_time (ptr_ptr, info_ptr)
+png_struct *png_ptr;
 png_info *info_ptr;
 #endif
 {
@@ -312,18 +312,20 @@
         "July", "August", "September", "October", "November", "December"
     };
 
-  if (info_ptr->valid & PNG_INFO_tIME) {
-    if (info_ptr->mod_time.month < 1 ||
-      info_ptr->mod_time.month >= ARRAY_SIZE(month)) {
+  if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tIME)) {
+    png_timep mod_timep;
+    png_get_tIME(png_ptr, info_ptr, &mod_timep);
+    if (mod_timep->month < 1 ||
+      mod_timep->month >= ARRAY_SIZE(month)) {
       pm_message("tIME chunk in PNG input is invalid; "
                  "modification time of image is unknown.  "
                  "The month value, which should be in the range "
-                 "1-12, is %u", info_ptr->mod_time.month);
+                 "1-12, is %u", mod_timep->month);
     } else
     pm_message ("modification time: %02d %s %d %02d:%02d:%02d",
-                info_ptr->mod_time.day, month[info_ptr->mod_time.month],
-                info_ptr->mod_time.year, info_ptr->mod_time.hour,
-                info_ptr->mod_time.minute, info_ptr->mod_time.second);
+                mod_timep->day, month[mod_timep->month],
+                mod_timep->year, mod_timep->hour,
+                mod_timep->minute, mod_timep->second);
   }
 }
 
@@ -360,12 +362,12 @@
 
 
 static void
-dump_png_info(png_info *info_ptr) {
+dump_png_info(png_struct *png_ptr, png_info *info_ptr) {
 
     const char *type_string;
     const char *filter_string;
 
-    switch (info_ptr->color_type) {
+    switch (png_get_color_type(png_ptr, info_ptr)) {
       case PNG_COLOR_TYPE_GRAY:
         type_string = "gray";
         break;
@@ -387,90 +389,106 @@
         break;
     }
 
-    switch (info_ptr->filter_type) {
+    switch (png_get_filter_type(png_ptr, info_ptr)) {
     case PNG_FILTER_TYPE_BASE:
         asprintfN(&filter_string, "base filter");
         break;
     default:
         asprintfN(&filter_string, "unknown filter type %d", 
-                  info_ptr->filter_type);
+                  png_get_filter_type(png_ptr, info_ptr));
     }
 
+    {
+    png_uint_32 width, height;
+    int bit_depth, color_type;
+    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, NULL, NULL, NULL);
     pm_message("reading a %ldw x %ldh image, %d bit%s",
-               info_ptr->width, info_ptr->height,
-               info_ptr->bit_depth, info_ptr->bit_depth > 1 ? "s" : "");
+               width, height,
+               bit_depth, bit_depth > 1 ? "s" : "");
+    }
     pm_message("%s, %s, %s",
                type_string,
-               info_ptr->interlace_type ? 
+               png_get_interlace_type(png_ptr, info_ptr) ? 
                "Adam7 interlaced" : "not interlaced",
                filter_string);
+    {
+    png_color_16p bkgp;
+    if(png_get_bKGD(png_ptr, info_ptr, &bkgp) && (bkgp != NULL))
     pm_message("background {index, gray, red, green, blue} = "
                "{%d, %d, %d, %d, %d}",
-               info_ptr->background.index,
-               info_ptr->background.gray,
-               info_ptr->background.red,
-               info_ptr->background.green,
-               info_ptr->background.blue);
+               bkgp->index,
+               bkgp->gray,
+               bkgp->red,
+               bkgp->green,
+               bkgp->blue);
+    }
 
     strfree(filter_string);
 
-    if (info_ptr->valid & PNG_INFO_tRNS)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) {
+	int num_trans;
+	png_get_tRNS(png_ptr, info_ptr, NULL, &num_trans, NULL);
         pm_message("tRNS chunk (transparency): %u entries",
-                   info_ptr->num_trans);
-    else
+                   num_trans);
+    } else
         pm_message("tRNS chunk (transparency): not present");
 
-    if (info_ptr->valid & PNG_INFO_gAMA)
-        pm_message("gAMA chunk (image gamma): gamma = %4.2f", info_ptr->gamma);
-    else
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA)) {
+	double gamma;
+	png_get_gAMA(png_ptr, info_ptr, &gamma);
+        pm_message("gAMA chunk (image gamma): gamma = %4.2f", gamma);
+    } else
         pm_message("gAMA chunk (image gamma): not present");
 
-    if (info_ptr->valid & PNG_INFO_sBIT)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT))
         pm_message("sBIT chunk: present");
     else
         pm_message("sBIT chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_cHRM)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM))
         pm_message("cHRM chunk: present");
     else
         pm_message("cHRM chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_PLTE)
-        pm_message("PLTE chunk: %d entries", info_ptr->num_palette);
-    else
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_PLTE)) {
+	png_colorp palette;
+	int num_palette;
+	png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);
+        pm_message("PLTE chunk: %d entries", num_palette);
+    } else
         pm_message("PLTE chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_bKGD)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))
         pm_message("bKGD chunk: present");
     else
         pm_message("bKGD chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_hIST)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_hIST))
         pm_message("hIST chunk: present");
     else
         pm_message("hIST chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_pHYs)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_pHYs))
         pm_message("pHYs chunk: present");
     else
         pm_message("pHYs chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_oFFs)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_oFFs))
         pm_message("oFFs chunk: present");
     else
         pm_message("oFFs chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_tIME)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tIME))
         pm_message("tIME chunk: present");
     else
         pm_message("tIME chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_pCAL)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_pCAL))
         pm_message("pCAL chunk: present");
     else
         pm_message("pCAL chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_sRGB)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB))
         pm_message("sRGB chunk: present");
     else
         pm_message("sRGB chunk: not present");
@@ -480,6 +498,7 @@
 
 static bool
 isTransparentColor(pngcolor   const color,
+                   png_struct * const png_ptr,
                    png_info * const info_ptr,
                    double     const totalgamma) {
 /*----------------------------------------------------------------------------
@@ -488,9 +507,9 @@
 -----------------------------------------------------------------------------*/
     bool retval;
 
-    if (info_ptr->valid & PNG_INFO_tRNS) {
-        const png_color_16 * const transColorP = &info_ptr->trans_values;
-    
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) {
+        png_color_16p transColorP;
+	png_get_tRNS(png_ptr, info_ptr, NULL, NULL, &transColorP);
 
         /* There seems to be a problem here: you can't compare real
            numbers for equality.  Also, I'm not sure the gamma
@@ -538,9 +557,11 @@
         *totalgammaP = -1.0;
     else {
         float imageGamma;
-        if (info_ptr->valid & PNG_INFO_gAMA)
-            imageGamma = info_ptr->gamma;
-        else {
+        if (png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA)) {
+           double gamma;
+	    png_get_gAMA(png_ptr, info_ptr, &gamma);
+           imageGamma = gamma;
+	} else {
             if (verbose)
                 pm_message("PNG doesn't specify image gamma.  Assuming 1.0");
             imageGamma = 1.0;
@@ -558,7 +579,7 @@
             /* in case of gamma-corrections, sBIT's as in the
                PNG-file are not valid anymore 
             */
-            info_ptr->valid &= ~PNG_INFO_sBIT;
+	    png_set_invalid(png_ptr, info_ptr, PNG_INFO_sBIT);
             if (verbose)
                 pm_message("image gamma is %4.2f, "
                            "converted for display gamma of %4.2f",
@@ -570,20 +591,23 @@
 
 
 static bool
-paletteHasPartialTransparency(png_info * const info_ptr) {
+paletteHasPartialTransparency(png_struct * const png_ptr, png_info * const info_ptr) {
 
     bool retval;
 
-    if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
-        if (info_ptr->valid & PNG_INFO_tRNS) {
+    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE) {
+        if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) {
             bool foundGray;
             unsigned int i;
+	    int num_trans;
+	    png_bytep trans_alpha;
+	    png_get_tRNS(png_ptr, info_ptr, &trans_alpha, &num_trans, NULL);
             
             for (i = 0, foundGray = FALSE;
-                 i < info_ptr->num_trans && !foundGray;
+                 i < num_trans && !foundGray;
                  ++i) {
-                if (info_ptr->trans[i] != 0 &&
-                    info_ptr->trans[i] != maxval) {
+                if (trans_alpha[i] != 0 &&
+                    trans_alpha[i] != maxval) {
                     foundGray = TRUE;
                 }
             }
@@ -612,13 +636,14 @@
   Return the result as *maxvalP.
 -----------------------------------------------------------------------------*/
     /* Initial assumption of maxval */
-    if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+    png_byte color_type = png_get_color_type(png_ptr, info_ptr);
+    if (color_type == PNG_COLOR_TYPE_PALETTE) {
         if (alpha == ALPHA_ONLY) {
-            if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-                info_ptr->color_type == PNG_COLOR_TYPE_RGB)
+            if (color_type == PNG_COLOR_TYPE_GRAY ||
+                color_type == PNG_COLOR_TYPE_RGB)
                 /* The alpha mask will be all opaque, so maxval 1 is plenty */
                 *maxvalP = 1;
-            else if (paletteHasPartialTransparency(info_ptr))
+            else if (paletteHasPartialTransparency(png_ptr, info_ptr))
                 /* Use same maxval as PNG transparency palette for simplicity*/
                 *maxvalP = 255;
             else
@@ -628,7 +653,7 @@
             /* Use same maxval as PNG palette for simplicity */
             *maxvalP = 255;
     } else {
-        *maxvalP = (1l << info_ptr->bit_depth) - 1;
+        *maxvalP = (1l << png_get_bit_depth(png_ptr, info_ptr)) - 1;
     }
 
     /* sBIT handling is very tricky. If we are extracting only the
@@ -641,20 +666,25 @@
        is used 
     */
     
-    if (info_ptr->valid & PNG_INFO_sBIT) {
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT)) {
+	png_color_8p sig_bit;
+	png_get_sBIT(png_ptr, info_ptr, &sig_bit);
         switch (alpha) {
         case ALPHA_MIX:
-            if (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
-                info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+            if (color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+                color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
                 break;
-            if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
-                (info_ptr->valid & PNG_INFO_tRNS)) {
+            if (color_type == PNG_COLOR_TYPE_PALETTE &&
+                png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) {
 
+                png_bytep trans_alpha;
+		int num_trans;
                 bool trans_mix;
                 unsigned int i;
                 trans_mix = TRUE;
-                for (i = 0; i < info_ptr->num_trans; ++i)
-                    if (info_ptr->trans[i] != 0 && info_ptr->trans[i] != 255) {
+		png_get_tRNS(png_ptr, info_ptr, &trans_alpha, &num_trans, NULL);
+                for (i = 0; i < num_trans; ++i)
+                    if (trans_alpha[i] != 0 && trans_alpha[i] != 255) {
                         trans_mix = FALSE;
                         break;
                     }
@@ -665,70 +695,73 @@
             /* else fall though to normal case */
 
         case ALPHA_NONE:
-            if ((info_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
-                 info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
-                 info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
-                (info_ptr->sig_bit.red != info_ptr->sig_bit.green ||
-                 info_ptr->sig_bit.red != info_ptr->sig_bit.blue) &&
+            if ((color_type == PNG_COLOR_TYPE_PALETTE ||
+                 color_type == PNG_COLOR_TYPE_RGB ||
+                 color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
+                (sig_bit->red != sig_bit->green ||
+                 sig_bit->red != sig_bit->blue) &&
                 alpha == ALPHA_NONE) {
                 pm_message("This program cannot handle "
                            "different bit depths for color channels");
                 pm_message("writing file with %d bit resolution",
-                           info_ptr->bit_depth);
+                           png_get_bit_depth(png_ptr, info_ptr));
                 *errorlevelP = PNMTOPNG_WARNING_LEVEL;
             } else {
-                if ((info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) &&
-                    (info_ptr->sig_bit.red < 255)) {
+                if ((color_type == PNG_COLOR_TYPE_PALETTE) &&
+                    sig_bit->red < 255) {
                     unsigned int i;
-                    for (i = 0; i < info_ptr->num_palette; ++i) {
-                        info_ptr->palette[i].red   >>=
-                            (8 - info_ptr->sig_bit.red);
-                        info_ptr->palette[i].green >>=
-                            (8 - info_ptr->sig_bit.green);
-                        info_ptr->palette[i].blue  >>=
-                            (8 - info_ptr->sig_bit.blue);
+		    png_colorp palette;
+		    int num_palette;
+		    png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);
+                    for (i = 0; i < num_palette; ++i) {
+                        palette[i].red   >>=
+                            (8 - sig_bit->red);
+                        palette[i].green >>=
+                            (8 - sig_bit->green);
+                        palette[i].blue  >>=
+                            (8 - sig_bit->blue);
                     }
-                    *maxvalP = (1l << info_ptr->sig_bit.red) - 1;
+                    *maxvalP = (1l << sig_bit->red) - 1;
                     if (verbose)
                         pm_message ("image has fewer significant bits, "
                                     "writing file with %d bits per channel", 
-                                    info_ptr->sig_bit.red);
+                                    sig_bit->red);
                 } else
-                    if ((info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
-                         info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
-                        (info_ptr->sig_bit.red < info_ptr->bit_depth)) {
-                        png_set_shift (png_ptr, &(info_ptr->sig_bit));
-                        *maxvalP = (1l << info_ptr->sig_bit.red) - 1;
+                    if ((color_type == PNG_COLOR_TYPE_RGB ||
+                         color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
+                        (sig_bit->red < png_get_bit_depth(png_ptr, info_ptr))) {
+                        png_set_shift (png_ptr, sig_bit);
+                        *maxvalP = (1l << sig_bit->red) - 1;
                         if (verbose)
                             pm_message("image has fewer significant bits, "
                                        "writing file with %d "
                                        "bits per channel", 
-                                       info_ptr->sig_bit.red);
+                                       sig_bit->red);
                     } else 
-                        if ((info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-                             info_ptr->color_type ==
+                        if ((color_type == PNG_COLOR_TYPE_GRAY ||
+                             color_type ==
                                  PNG_COLOR_TYPE_GRAY_ALPHA) &&
-                            (info_ptr->sig_bit.gray < info_ptr->bit_depth)) {
-                            png_set_shift (png_ptr, &(info_ptr->sig_bit));
-                            *maxvalP = (1l << info_ptr->sig_bit.gray) - 1;
+                            (sig_bit->gray < png_get_bit_depth(png_ptr, info_ptr))) {
+                            png_set_shift (png_ptr, sig_bit);
+                            *maxvalP = (1l << sig_bit->gray) - 1;
                             if (verbose)
                                 pm_message("image has fewer significant bits, "
                                            "writing file with %d bits",
-                                           info_ptr->sig_bit.gray);
+                                           sig_bit->gray);
                         }
             }
             break;
 
         case ALPHA_ONLY:
-            if ((info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
-                 info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) && 
-                (info_ptr->sig_bit.gray < info_ptr->bit_depth)) {
-                png_set_shift (png_ptr, &(info_ptr->sig_bit));
+            if ((color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+                 color_type == PNG_COLOR_TYPE_GRAY_ALPHA) && 
+                (sig_bit->gray < png_get_bit_depth(png_ptr, info_ptr))) {
+                png_set_shift (png_ptr, sig_bit);
                 if (verbose)
                     pm_message ("image has fewer significant bits, "
                                 "writing file with %d bits", 
-                                info_ptr->sig_bit.alpha);
-                *maxvalP = (1l << info_ptr->sig_bit.alpha) - 1;
+                                sig_bit->alpha);
+                *maxvalP = (1l << sig_bit->alpha) - 1;
             }
             break;
 
@@ -739,22 +772,26 @@
 
 
 static bool
-imageHasColor(png_info * const info_ptr) {
+imageHasColor(png_struct * const png_ptr, png_info * const info_ptr) {
 
     bool retval;
+    png_byte color_type = png_get_color_type(png_ptr, info_ptr);
 
-    if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-        info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+    if (color_type == PNG_COLOR_TYPE_GRAY ||
+        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
 
         retval = FALSE;
-    else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+    else if (color_type == PNG_COLOR_TYPE_PALETTE) {
         bool foundColor;
         unsigned int i;
-            
+	png_colorp palette;
+	int num_palette;
+
+        png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);
         for (i = 0, foundColor = FALSE;
-             i < info_ptr->num_palette && !foundColor;
+             i < num_palette && !foundColor;
              ++i) {
-            if (iscolor(info_ptr->palette[i]))
+            if (iscolor(palette[i]))
                 foundColor = TRUE;
         }
         retval = foundColor;
@@ -767,14 +804,15 @@
 
 
 static void
-determineOutputType(png_info *          const info_ptr,
+determineOutputType(png_struct *        const png_ptr,
+                    png_info *          const info_ptr,
                     enum alpha_handling const alphaHandling,
                     pngcolor            const bgColor,
                     xelval              const maxval,
                     int *               const pnmTypeP) {
 
     if (alphaHandling != ALPHA_ONLY &&
-        (imageHasColor(info_ptr) || !isGrayscale(bgColor)))
+        (imageHasColor(png_ptr, info_ptr) || !isGrayscale(bgColor)))
         *pnmTypeP = PPM_TYPE;
     else {
         if (maxval > 1)
@@ -787,7 +825,8 @@
 
 
 static void
-getBackgroundColor(png_info *        const info_ptr,
+getBackgroundColor(png_struct *      const png_ptr,
+                   png_info *        const info_ptr,
                    const char *      const requestedColor,
                    float             const totalgamma,
                    xelval            const maxval,
@@ -809,19 +848,24 @@
         bgColorP->g = PPM_GETG(backcolor);
         bgColorP->b = PPM_GETB(backcolor);
 
-    } else if (info_ptr->valid & PNG_INFO_bKGD) {
+    } else if (png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD)) {
+	png_color_16p background;
+	png_colorp palette;
+	int num_palette;
+	png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);
+	png_get_bKGD(png_ptr, info_ptr, &background);
         /* didn't manage to get libpng to work (bugs?) concerning background
            processing, therefore we do our own.
         */
-        switch (info_ptr->color_type) {
+        switch (png_get_color_type(png_ptr, info_ptr)) {
         case PNG_COLOR_TYPE_GRAY:
         case PNG_COLOR_TYPE_GRAY_ALPHA:
             bgColorP->r = bgColorP->g = bgColorP->b = 
-                gamma_correct(info_ptr->background.gray, totalgamma);
+                gamma_correct(background->gray, totalgamma);
             break;
         case PNG_COLOR_TYPE_PALETTE: {
             png_color const rawBgcolor = 
-                info_ptr->palette[info_ptr->background.index];
+                palette[background->index];
             bgColorP->r = gamma_correct(rawBgcolor.red, totalgamma);
             bgColorP->g = gamma_correct(rawBgcolor.green, totalgamma);
             bgColorP->b = gamma_correct(rawBgcolor.blue, totalgamma);
@@ -829,7 +873,7 @@
         break;
         case PNG_COLOR_TYPE_RGB:
         case PNG_COLOR_TYPE_RGB_ALPHA: {
-            png_color_16 const rawBgcolor = info_ptr->background;
+            png_color_16 const rawBgcolor = *background;
             
             bgColorP->r = gamma_correct(rawBgcolor.red,   totalgamma);
             bgColorP->g = gamma_correct(rawBgcolor.green, totalgamma);
@@ -842,12 +886,32 @@
         bgColorP->r = bgColorP->g = bgColorP->b = maxval;
 }
 
+static png_color_16p get_png_trans_colorp(png_struct *png_ptr, png_info *info_ptr)
+{
+    png_color_16p trans_color;
+    png_get_tRNS(png_ptr, info_ptr, NULL, NULL, &trans_color);
+    return trans_color;
+}
+
+static int get_png_num_trans(png_struct *png_ptr, png_info *info_ptr)
+{
+    int num_trans;
+    png_get_tRNS(png_ptr, info_ptr, NULL, &num_trans, NULL);
+    return num_trans;
+}
 
+static png_bytep get_png_trans_alpha(png_struct *png_ptr, png_info *info_ptr)
+{
+    png_bytep trans_alpha;
+    png_get_tRNS(png_ptr, info_ptr, &trans_alpha, NULL, NULL);
+    return trans_alpha;
+}
 
 static void
 writePnm(FILE *              const ofP,
          xelval              const maxval,
          int                 const pnm_type,
+	 png_struct *        const png_ptr,
          png_info *          const info_ptr,
          png_byte **         const png_image,
          pngcolor            const bgColor,
@@ -865,6 +929,10 @@
 -----------------------------------------------------------------------------*/
     xel * xelrow;
     unsigned int row;
+    png_uint_32 width, height;
+    int bit_depth, color_type;
+    png_colorp palette;
+    int num_palette;
 
     if (verbose)
         pm_message ("writing a %s file (maxval=%u)",
@@ -874,25 +942,28 @@
                     "UNKNOWN!", 
                     maxval);
     
-    xelrow = pnm_allocrow(info_ptr->width);
+    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, NULL, NULL, NULL);
+    png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);
 
-    pnm_writepnminit(stdout, info_ptr->width, info_ptr->height, maxval,
+    xelrow = pnm_allocrow(width);
+
+    pnm_writepnminit(stdout, width, height, maxval,
                      pnm_type, FALSE);
 
-    for (row = 0; row < info_ptr->height; ++row) {
+    for (row = 0; row < height; ++row) {
         png_byte * png_pixelP;
         int col;
 
         png_pixelP = &png_image[row][0];  /* initial value */
-        for (col = 0; col < info_ptr->width; ++col) {
-            switch (info_ptr->color_type) {
+        for (col = 0; col < width; ++col) {
+            switch (color_type) {
             case PNG_COLOR_TYPE_GRAY: {
                 pngcolor fgColor;
                 fgColor.r = fgColor.g = fgColor.b = get_png_val(png_pixelP);
                 setXel(&xelrow[col], fgColor, bgColor, alpha_handling,
-                       ((info_ptr->valid & PNG_INFO_tRNS) &&
+                       ((png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) &&
                         (fgColor.r == 
-                         gamma_correct(info_ptr->trans_values.gray,
+                         gamma_correct(get_png_trans_colorp(png_ptr, info_ptr)->gray,
                                        totalgamma))) ?
                        0 : maxval);
             }
@@ -910,7 +981,7 @@
 
             case PNG_COLOR_TYPE_PALETTE: {
                 png_uint_16 const index        = get_png_val(png_pixelP);
-                png_color   const paletteColor = info_ptr->palette[index];
+                png_color   const paletteColor = palette[index];
 
                 pngcolor fgColor;
 
@@ -919,9 +990,9 @@
                 fgColor.b = paletteColor.blue;
 
                 setXel(&xelrow[col], fgColor, bgColor, alpha_handling,
-                       (info_ptr->valid & PNG_INFO_tRNS) &&
-                       index < info_ptr->num_trans ?
-                       info_ptr->trans[index] : maxval);
+                       (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) &&
+                       index < get_png_num_trans(png_ptr, info_ptr) ?
+                       get_png_trans_alpha(png_ptr, info_ptr)[index] : maxval);
             }
             break;
                 
@@ -932,7 +1003,7 @@
                 fgColor.g = get_png_val(png_pixelP);
                 fgColor.b = get_png_val(png_pixelP);
                 setXel(&xelrow[col], fgColor, bgColor, alpha_handling,
-                       isTransparentColor(fgColor, info_ptr, totalgamma) ?
+                       isTransparentColor(fgColor, png_ptr, info_ptr, totalgamma) ?
                        0 : maxval);
             }
             break;
@@ -950,10 +1021,10 @@
             break;
 
             default:
-                pm_error ("unknown PNG color type: %d", info_ptr->color_type);
+                pm_error ("unknown PNG color type: %d", color_type);
             }
         }
-        pnm_writepnmrow(ofP, xelrow, info_ptr->width, maxval, pnm_type, FALSE);
+        pnm_writepnmrow(ofP, xelrow, width, maxval, pnm_type, FALSE);
     }
     pnm_freerow (xelrow);
 }
@@ -974,6 +1045,8 @@
     int pnm_type;
     pngcolor bgColor;
     float totalgamma;
+    png_uint_32 width, height;
+    int bit_depth, color_type;
 
     *errorlevelP = 0;
 
@@ -995,29 +1068,30 @@
     png_init_io (png_ptr, ifp);
     png_set_sig_bytes (png_ptr, SIG_CHECK_SIZE);
     png_read_info (png_ptr, info_ptr);
+    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, NULL, NULL, NULL);
 
-    MALLOCARRAY(png_image, info_ptr->height);
+    MALLOCARRAY(png_image, height);
     if (png_image == NULL) {
         png_destroy_read_struct (&png_ptr, &info_ptr, (png_infopp)NULL);
         pm_closer (ifp);
         pm_error ("couldn't allocate space for image");
     }
 
-    if (info_ptr->bit_depth == 16)
-        linesize = 2 * info_ptr->width;
+    if (bit_depth == 16)
+        linesize = 2 * width;
     else
-        linesize = info_ptr->width;
+        linesize = width;
 
-    if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+    if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
         linesize *= 2;
     else
-        if (info_ptr->color_type == PNG_COLOR_TYPE_RGB)
+        if (color_type == PNG_COLOR_TYPE_RGB)
             linesize *= 3;
         else
-            if (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+            if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
                 linesize *= 4;
 
-    for (y = 0 ; y < info_ptr->height ; y++) {
+    for (y = 0 ; y < height ; y++) {
         png_image[y] = malloc (linesize);
         if (png_image[y] == NULL) {
             for (x = 0 ; x < y ; x++)
@@ -1029,7 +1103,7 @@
         }
     }
 
-    if (info_ptr->bit_depth < 8)
+    if (bit_depth < 8)
         png_set_packing (png_ptr);
 
     setupGammaCorrection(png_ptr, info_ptr, cmdline.gamma, &totalgamma);
@@ -1037,7 +1111,7 @@
     setupSignificantBits(png_ptr, info_ptr, cmdline.alpha,
                          &maxval, errorlevelP);
 
-    getBackgroundColor(info_ptr, cmdline.background, totalgamma, maxval,
+    getBackgroundColor(png_ptr, info_ptr, cmdline.background, totalgamma, maxval,
                        &bgColor);
 
     png_read_image (png_ptr, png_image);
@@ -1048,16 +1122,18 @@
        completes.  That's because it comes from chunks that are at the
        end of the stream.
     */
-        dump_png_info(info_ptr);
+        dump_png_info(png_ptr, info_ptr);
 
     if (mtime)
-        show_time (info_ptr);
+        show_time (png_ptr, info_ptr);
     if (tfp)
-        save_text (info_ptr, tfp);
+        save_text (png_ptr, info_ptr, tfp);
 
-    if (info_ptr->valid & PNG_INFO_pHYs) {
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_pHYs)) {
         float r;
-        r = (float)info_ptr->x_pixels_per_unit / info_ptr->y_pixels_per_unit;
+	png_uint_32 res_x, res_y;
+	png_get_pHYs(png_ptr, info_ptr, &res_x, &res_y, NULL);
+        r = (float)res_x / res_y;
         if (r != 1.0) {
             pm_message ("warning - non-square pixels; "
                         "to fix do a 'pamscale -%cscale %g'",
@@ -1067,13 +1143,13 @@
         }
     }
 
-    determineOutputType(info_ptr, cmdline.alpha, bgColor, maxval, &pnm_type);
+    determineOutputType(png_ptr, info_ptr, cmdline.alpha, bgColor, maxval, &pnm_type);
 
-    writePnm(stdout, maxval, pnm_type, info_ptr, png_image, bgColor, 
+    writePnm(stdout, maxval, pnm_type, png_ptr, info_ptr, png_image, bgColor, 
              cmdline.alpha, totalgamma);
 
     fflush(stdout);
-    for (y = 0 ; y < info_ptr->height ; y++)
+    for (y = 0 ; y < height ; y++)
         free (png_image[y]);
     free (png_image);
     png_destroy_read_struct (&png_ptr, &info_ptr, (png_infopp)NULL);
--- netpbm-10.35.83/converter/other/pngtxt.c.orig	2006-08-19 05:12:28.000000000 +0200
+++ netpbm-10.35.83/converter/other/pngtxt.c	2012-01-29 09:59:22.463431985 +0100
@@ -240,7 +240,8 @@
 
 
 void 
-pnmpng_read_text (png_info * const info_ptr, 
+pnmpng_read_text (png_struct * const png_ptr,
+                  png_info * const info_ptr, 
                   FILE *     const tfp, 
                   bool       const ztxt,
                   bool       const verbose) {
@@ -250,15 +251,16 @@
     unsigned int commentIdx;
     bool noCommentsYet;
     bool eof;
+    png_textp text;
     unsigned int allocatedComments;
-        /* Number of entries currently allocated for the info_ptr->text
+        /* Number of entries currently allocated for the text
            array 
         */
 
     allocatedComments = 256;  /* initial value */
 
-    MALLOCARRAY(info_ptr->text, allocatedComments);
-    if (info_ptr->text == NULL) 
+    MALLOCARRAY(text, allocatedComments);
+    if (text == NULL) 
         pm_error("unable to allocate memory for comment array");
 
     commentIdx = 0;
@@ -273,7 +275,7 @@
             if (lineLength == 0) {
                 /* skip this empty line */
             } else {
-                handleArrayAllocation(&info_ptr->text, &allocatedComments,
+                handleArrayAllocation(&text, &allocatedComments,
                                       commentIdx);
                 if ((textline[0] != ' ') && (textline[0] != '\t')) {
                     /* Line doesn't start with white space, which
@@ -285,7 +287,7 @@
                         ++commentIdx;
                     noCommentsYet = FALSE;
 
-                    startComment(&info_ptr->text[commentIdx], 
+                    startComment(&text[commentIdx], 
                                  textline, lineLength, ztxt);
                 } else {
                     /* Line starts with whitespace, which means it is
@@ -295,20 +297,20 @@
                         pm_error("Invalid comment file format: "
                                  "first line is a continuation line! "
                                  "(It starts with whitespace)");
-                    continueComment(&info_ptr->text[commentIdx], 
+                    continueComment(&text[commentIdx], 
                                     textline, lineLength);
                 }
             }
             strfree(textline);
         }
     } 
-    if (noCommentsYet)
-        info_ptr->num_text = 0;
-    else
-        info_ptr->num_text = commentIdx + 1;
+    if (!noCommentsYet)
+        png_set_text(png_ptr, info_ptr, text, commentIdx + 1);
 
     if (verbose)
-        pm_message("%d comments placed in text chunk", info_ptr->num_text);
+        pm_message("%d comments placed in text chunk", commentIdx + 1);
+
+    free(text);
 }
 
 
--- netpbm-10.35.83/converter/other/pngtxt.h.orig	2006-08-19 05:12:28.000000000 +0200
+++ netpbm-10.35.83/converter/other/pngtxt.h	2012-01-29 09:59:59.566766561 +0100
@@ -5,7 +5,8 @@
 #include <png.h>
 
 void 
-pnmpng_read_text (png_info * const info_ptr, 
+pnmpng_read_text (png_struct * const png_ptr,
+                  png_info * const info_ptr, 
                   FILE *     const tfp, 
                   bool const ztxt,
                   bool const verbose);
--- netpbm-10.35.83/converter/other/pamrgbatopng.c.orig	2006-08-19 05:12:28.000000000 +0200
+++ netpbm-10.35.83/converter/other/pamrgbatopng.c	2012-01-29 14:02:47.790587693 +0100
@@ -101,10 +101,9 @@
     if (!infoP)
         pm_error("Could not allocate PNG info structure");
     else {
-        infoP->width      = pamP->width;
-        infoP->height     = pamP->height;
-        infoP->bit_depth  = 8;
-        infoP->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
+        png_set_IHDR(pngP, infoP,
+                     pamP->width, pamP->height,
+		     8, PNG_COLOR_TYPE_RGB_ALPHA, 0, 0, 0);
         
         png_init_io(pngP, ofP);
 
