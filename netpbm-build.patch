--- netpbm-10.47.73/converter/other/pnmtopng.c.orig	2019-06-28 23:02:17.000000000 +0200
+++ netpbm-10.47.73/converter/other/pnmtopng.c	2019-07-27 10:44:23.878530313 +0200
@@ -59,7 +59,8 @@
 #include <assert.h>
 #include <string.h> /* strcat() */
 #include <limits.h>
-#include <png.h>    /* includes zlib.h and setjmp.h */
+#include <png.h>    /* includes setjmp.h */
+#include <zlib.h>
 
 #include "pm_c_util.h"
 #include "pnm.h"
@@ -69,20 +70,6 @@
 #include "nstring.h"
 #include "version.h"
 
-#if PNG_LIBPNG_VER >= 10500
-#error Your PNG library (<png.h>) is incompatible with this Netpbm source code.
-#error You need either an older PNG library (older than 1.5) or
-#error newer Netpbm source code (at least 10.55)
-#endif
-
-/* A hack until we can remove direct access to png_info from the program */
-#if PNG_LIBPNG_VER >= 10400
-#define trans_values trans_color
-#define TRANS_ALPHA trans_alpha
-#else
-#define TRANS_ALPHA trans
-#endif
-
 
 struct zlibCompression {
     /* These are parameters that describe a form of zlib compression.
@@ -2131,6 +2118,7 @@ makePngLine(png_byte *           const l
             gray *               const alpha_mask,
             colorhash_table      const cht,
             coloralphahash_table const caht,
+            png_struct *         const png_ptr,
             png_info *           const info_ptr,
             xelval               const png_maxval,
             unsigned int         const depth) {
@@ -2142,21 +2130,22 @@ makePngLine(png_byte *           const l
     for (col = 0; col < cols; ++col) {
         xel p_png;
         xel const p = xelrow[col];
+        png_byte color_type = png_get_color_type(png_ptr, info_ptr);
         PPM_DEPTH(p_png, p, maxval, png_maxval);
-        if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-            info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
+        if (color_type == PNG_COLOR_TYPE_GRAY ||
+            color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
             if (depth == 16)
                 *pp++ = PNM_GET1(p_png) >> 8;
             *pp++ = PNM_GET1(p_png) & 0xff;
-        } else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+        } else if (color_type == PNG_COLOR_TYPE_PALETTE) {
             unsigned int paletteIndex;
             if (alpha)
                 paletteIndex = lookupColorAlpha(caht, &p, &alpha_mask[col]);
             else
                 paletteIndex = ppm_lookupcolor(cht, &p);
             *pp++ = paletteIndex;
-        } else if (info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
-                   info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
+        } else if (color_type == PNG_COLOR_TYPE_RGB ||
+                   color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
             if (depth == 16)
                 *pp++ = PPM_GETR(p_png) >> 8;
             *pp++ = PPM_GETR(p_png) & 0xff;
@@ -2169,7 +2158,7 @@ makePngLine(png_byte *           const l
         } else
             pm_error("INTERNAL ERROR: undefined color_type");
                 
-        if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA) {
+        if (color_type & PNG_COLOR_MASK_ALPHA) {
             int const png_alphaval = (int)
                 alpha_mask[col] * (float) png_maxval / maxval + 0.5;
             if (depth == 16)
@@ -2226,7 +2215,7 @@ writeRaster(png_struct *         const p
             
             makePngLine(line, xelrow, cols, maxval,
                         alpha, alpha ? alpha_mask[row] : NULL,
-                        cht, caht, info_ptr, png_maxval, depth);
+                        cht, caht, png_ptr, info_ptr, png_maxval, depth);
 
             png_write_row(png_ptr, line);
         }
@@ -2238,12 +2227,12 @@ writeRaster(png_struct *         const p
 
 static void
 doGamaChunk(struct cmdlineInfo const cmdline,
+            png_struct *       const png_ptr,
             png_info *         const info_ptr) {
             
     if (cmdline.gammaSpec) {
         /* gAMA chunk */
-        info_ptr->valid |= PNG_INFO_gAMA;
-        info_ptr->gamma = cmdline.gamma;
+        png_set_gAMA(png_ptr, info_ptr, cmdline.gamma);	   
     }
 }
 
@@ -2251,20 +2240,16 @@ doGamaChunk(struct cmdlineInfo const cmd
 
 static void
 doChrmChunk(struct cmdlineInfo const cmdline,
+            png_struct *       const png_ptr,
             png_info *         const info_ptr) {
 
     if (cmdline.rgbSpec) {
         /* cHRM chunk */
-        info_ptr->valid |= PNG_INFO_cHRM;
-
-        info_ptr->x_white = cmdline.rgb.wx;
-        info_ptr->y_white = cmdline.rgb.wy;
-        info_ptr->x_red   = cmdline.rgb.rx;
-        info_ptr->y_red   = cmdline.rgb.ry;
-        info_ptr->x_green = cmdline.rgb.gx;
-        info_ptr->y_green = cmdline.rgb.gy;
-        info_ptr->x_blue  = cmdline.rgb.bx;
-        info_ptr->y_blue  = cmdline.rgb.by;
+        png_set_cHRM(png_ptr, info_ptr,
+                     cmdline.rgb.wx, cmdline.rgb.wy,
+                     cmdline.rgb.rx, cmdline.rgb.ry,
+                     cmdline.rgb.gx, cmdline.rgb.gy,
+                     cmdline.rgb.bx, cmdline.rgb.by);
     }
 }
 
@@ -2272,15 +2257,13 @@ doChrmChunk(struct cmdlineInfo const cmd
 
 static void
 doPhysChunk(struct cmdlineInfo const cmdline,
+            png_struct *       const png_ptr,
             png_info *         const info_ptr) {
 
     if (cmdline.sizeSpec) {
         /* pHYS chunk */
-        info_ptr->valid |= PNG_INFO_pHYs;
-
-        info_ptr->x_pixels_per_unit = cmdline.size.x;
-        info_ptr->y_pixels_per_unit = cmdline.size.y;
-        info_ptr->phys_unit_type    = cmdline.size.unit;
+        png_set_pHYs(png_ptr, info_ptr,
+                     cmdline.size.x, cmdline.size.y, cmdline.size.unit);
     }
 }
 
@@ -2289,26 +2272,29 @@ doPhysChunk(struct cmdlineInfo const cmd
 
 static void
 doTimeChunk(struct cmdlineInfo const cmdline,
+            png_struct *       const png_ptr,
             png_info *         const info_ptr) {
 
     if (cmdline.modtimeSpec) {
         /* tIME chunk */
-        info_ptr->valid |= PNG_INFO_tIME;
-
-        png_convert_from_time_t(&info_ptr->mod_time, cmdline.modtime);
+        png_time ptime;
+        png_convert_from_time_t(&ptime, cmdline.modtime);
+        png_set_tIME(png_ptr, info_ptr, &ptime);
     }
 }
 
 
 
 static void
-doSbitChunk(png_info * const pngInfoP,
+doSbitChunk(png_struct * const png_ptr,
+            png_info * const pngInfoP,
             xelval     const pngMaxval,
             xelval     const maxval,
             bool       const alpha,
             xelval     const alphaMaxval) {
 
-    if (pngInfoP->color_type != PNG_COLOR_TYPE_PALETTE &&
+    png_byte color_type = png_get_color_type(png_ptr, pngInfoP);
+    if (color_type != PNG_COLOR_TYPE_PALETTE &&
         (pngMaxval > maxval || (alpha && pngMaxval > alphaMaxval))) {
 
         /* We're writing in a bit depth that doesn't match the maxval
@@ -2327,27 +2313,27 @@ doSbitChunk(png_info * const pngInfoP,
            sBIT chunk.
         */
 
-        pngInfoP->valid |= PNG_INFO_sBIT;
-
+        png_color_8 sbit;
         {
             int const sbitval = pm_maxvaltobits(MIN(maxval, pngMaxval));
 
-            if (pngInfoP->color_type & PNG_COLOR_MASK_COLOR) {
-                pngInfoP->sig_bit.red   = sbitval;
-                pngInfoP->sig_bit.green = sbitval;
-                pngInfoP->sig_bit.blue  = sbitval;
+            if (color_type & PNG_COLOR_MASK_COLOR) {
+                sbit.red   = sbitval;
+                sbit.green = sbitval;
+                sbit.blue  = sbitval;
             } else
-                pngInfoP->sig_bit.gray = sbitval;
+                sbit.gray = sbitval;
             
             if (verbose)
                 pm_message("Writing sBIT chunk with bits = %d", sbitval);
         }
-        if (pngInfoP->color_type & PNG_COLOR_MASK_ALPHA) {
-            pngInfoP->sig_bit.alpha =
+        if (color_type & PNG_COLOR_MASK_ALPHA) {
+            sbit.alpha =
                 pm_maxvaltobits(MIN(alphaMaxval, pngMaxval));
             if (verbose)
-                pm_message("  alpha bits = %d", pngInfoP->sig_bit.alpha);
+                pm_message("  alpha bits = %d", sbit.alpha);
         }
+        png_set_sBIT(png_ptr, pngInfoP, &sbit);
     }
 }
 
@@ -2628,43 +2614,40 @@ convertpnm(struct cmdlineInfo const cmdl
     pm_error ("setjmp returns error condition (2)");
   }
 
-  png_init_io (png_ptr, stdout);
-  info_ptr->width = cols;
-  info_ptr->height = rows;
-  info_ptr->bit_depth = depth;
-
+  {
+  int color_type;
   if (colorMapped)
-    info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
+    color_type = PNG_COLOR_TYPE_PALETTE;
   else if (pnm_type == PPM_TYPE)
-    info_ptr->color_type = PNG_COLOR_TYPE_RGB;
+    color_type = PNG_COLOR_TYPE_RGB;
   else
-    info_ptr->color_type = PNG_COLOR_TYPE_GRAY;
+    color_type = PNG_COLOR_TYPE_GRAY;
+
+  if (alpha && color_type != PNG_COLOR_TYPE_PALETTE)
+    color_type |= PNG_COLOR_MASK_ALPHA;
 
-  if (alpha && info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
-    info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
+  png_set_IHDR(png_ptr, info_ptr, cols, rows, depth, color_type, cmdline.interlace, 0, 0);
+  }
 
-  info_ptr->interlace_type = cmdline.interlace;
+  if (cmdline.interlace)
+    png_set_interlace_handling(png_ptr);
 
-  doGamaChunk(cmdline, info_ptr);
+  doGamaChunk(cmdline, png_ptr, info_ptr);
 
-  doChrmChunk(cmdline, info_ptr);
+  doChrmChunk(cmdline, png_ptr, info_ptr);
 
-  doPhysChunk(cmdline, info_ptr);
+  doPhysChunk(cmdline, png_ptr, info_ptr);
 
-  if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+  if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE) {
 
     /* creating PNG palette  (PLTE and tRNS chunks) */
 
     createPngPalette(palette_pnm, palette_size, maxval,
                      trans_pnm, trans_size, alpha_maxval, 
                      palette, trans);
-    info_ptr->valid |= PNG_INFO_PLTE;
-    info_ptr->palette = palette;
-    info_ptr->num_palette = palette_size;
+    png_set_PLTE(png_ptr, info_ptr, palette, palette_size);
     if (trans_size > 0) {
-        info_ptr->valid |= PNG_INFO_tRNS;
-        info_ptr->TRANS_ALPHA = trans;
-        info_ptr->num_trans = trans_size;   /* omit opaque values */
+        png_set_tRNS(png_ptr, info_ptr, trans, trans_size, NULL);
     }
     /* creating hIST chunk */
     if (cmdline.hist) {
@@ -2690,18 +2673,17 @@ convertpnm(struct cmdlineInfo const cmdl
 
         ppm_freecolorhash(cht);
 
-        info_ptr->valid |= PNG_INFO_hIST;
-        info_ptr->hist = histogram;
+        png_set_hIST(png_ptr, info_ptr, histogram);
         if (verbose)
             pm_message("histogram created");
     }
   } else { /* color_type != PNG_COLOR_TYPE_PALETTE */
-    if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-        info_ptr->color_type == PNG_COLOR_TYPE_RGB) {
+    png_byte color_type = png_get_color_type(png_ptr, info_ptr);
+    if (color_type == PNG_COLOR_TYPE_GRAY ||
+        color_type == PNG_COLOR_TYPE_RGB) {
         if (transparent > 0) {
-            info_ptr->valid |= PNG_INFO_tRNS;
-            info_ptr->trans_values = 
-                xelToPngColor_16(transcolor, maxval, png_maxval);
+            png_color_16 c = xelToPngColor_16(transcolor, maxval, png_maxval);
+            png_set_tRNS(png_ptr, info_ptr, NULL, 0, &c);
         }
     } else {
         /* This is PNG_COLOR_MASK_ALPHA.  Transparency will be handled
@@ -2709,13 +2691,17 @@ convertpnm(struct cmdlineInfo const cmdl
         */
     }
     if (verbose) {
-        if (info_ptr->valid && PNG_INFO_tRNS) 
+        png_color_16p trans_colorp = NULL;
+        if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) {
+            png_get_tRNS(png_ptr, info_ptr, NULL, NULL, &trans_colorp);
+        }
+        if(trans_colorp != NULL)
             pm_message("Transparent color {gray, red, green, blue} = "
                        "{%d, %d, %d, %d}",
-                       info_ptr->trans_values.gray,
-                       info_ptr->trans_values.red,
-                       info_ptr->trans_values.green,
-                       info_ptr->trans_values.blue);
+                       trans_colorp->gray,
+                       trans_colorp->red,
+                       trans_colorp->green,
+                       trans_colorp->blue);
         else
             pm_message("No transparent color");
     }
@@ -2723,29 +2709,29 @@ convertpnm(struct cmdlineInfo const cmdl
 
   /* bKGD chunk */
   if (cmdline.background) {
-      info_ptr->valid |= PNG_INFO_bKGD;
-      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
-          info_ptr->background.index = background_index;
+      png_color_16 bkgd;
+      if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE) {
+          bkgd.index = background_index;
       } else {
-          info_ptr->background = 
-              xelToPngColor_16(backcolor, maxval, png_maxval);
+          bkgd = xelToPngColor_16(backcolor, maxval, png_maxval);
           if (verbose)
               pm_message("Writing bKGD chunk with background color "
                          " {gray, red, green, blue} = {%d, %d, %d, %d}",
-                         info_ptr->background.gray, 
-                         info_ptr->background.red, 
-                         info_ptr->background.green, 
-                         info_ptr->background.blue ); 
+                         bkgd.gray, 
+                         bkgd.red, 
+                         bkgd.green, 
+                         bkgd.blue ); 
       }
+      png_set_bKGD(png_ptr, info_ptr, &bkgd);
   }
 
-  doSbitChunk(info_ptr, png_maxval, maxval, alpha, alpha_maxval);
+  doSbitChunk(png_ptr, info_ptr, png_maxval, maxval, alpha, alpha_maxval);
 
   /* tEXT and zTXT chunks */
   if (cmdline.text || cmdline.ztxt)
-      pnmpng_read_text(info_ptr, tfp, !!cmdline.ztxt, cmdline.verbose);
+      pnmpng_read_text(png_ptr, info_ptr, tfp, !!cmdline.ztxt, cmdline.verbose);
 
-  doTimeChunk(cmdline, info_ptr);
+  doTimeChunk(cmdline, png_ptr, info_ptr);
 
   if (cmdline.filterSetSpec)
       png_set_filter(png_ptr, 0, cmdline.filterSet);
@@ -2755,17 +2741,11 @@ convertpnm(struct cmdlineInfo const cmdl
 
   setZlibCompression(png_ptr, cmdline.zlibCompression);
 
+  png_init_io (png_ptr, stdout);
+
   /* write the png-info struct */
   png_write_info(png_ptr, info_ptr);
 
-  if (cmdline.text || cmdline.ztxt)
-      /* prevent from being written twice with png_write_end */
-      info_ptr->num_text = 0;
-
-  if (cmdline.modtime)
-      /* prevent from being written twice with png_write_end */
-      info_ptr->valid &= ~PNG_INFO_tIME;
-
   /* let libpng take care of, e.g., bit-depth conversions */
   png_set_packing (png_ptr);
 
--- netpbm-10.47.63/converter/other/pngtopnm.c.orig	2016-09-26 18:44:20.000000000 +0200
+++ netpbm-10.47.63/converter/other/pngtopnm.c	2016-10-26 20:40:14.913792290 +0200
@@ -32,19 +32,6 @@
 #include "shhopt.h"
 #include "pnm.h"
 
-#if PNG_LIBPNG_VER >= 10500
-#error Your PNG library (<png.h>) is incompatible with this Netpbm source code.
-#error You need either an older PNG library (older than 1.5) or
-#error newer Netpbm source code (at least 10.55)
-#endif
-
-/* A hack until we can remove direct access to png_info from the program */
-#if PNG_LIBPNG_VER >= 10400
-#define TRANS_ALPHA trans_alpha
-#else
-#define TRANS_ALPHA trans
-#endif
-
 
 enum alpha_handling {ALPHA_NONE, ALPHA_ONLY, ALPHA_MIX};
 
@@ -269,23 +256,25 @@ verifyFileIsPng(FILE *   const ifP,
 static unsigned int
 computePngLineSize(struct pngx * const pngxP) {
 
-    unsigned int const bytesPerSample =
-        pngxP->info_ptr->bit_depth == 16 ? 2 : 1;
-
+    png_uint_32 width;
+    int bit_depth, color_type;
+    unsigned int bytesPerSample;
     unsigned int samplesPerPixel;
 
-    switch (pngxP->info_ptr->color_type) {
+    png_get_IHDR(pngxP->png_ptr, pngxP->info_ptr, &width, NULL, &bit_depth, &color_type, NULL, NULL, NULL);
+    bytesPerSample = (bit_depth == 16) ? 2 : 1;
+    switch (color_type) {
     case PNG_COLOR_TYPE_GRAY_ALPHA: samplesPerPixel = 2; break;
     case PNG_COLOR_TYPE_RGB:        samplesPerPixel = 3; break;
     case PNG_COLOR_TYPE_RGB_ALPHA:  samplesPerPixel = 4; break;
     default:                        samplesPerPixel = 1;
     }
 
-    if (UINT_MAX / bytesPerSample / samplesPerPixel < pngxP->info_ptr->width)
+    if (UINT_MAX / bytesPerSample / samplesPerPixel < width)
         pm_error("Width %u of PNG is uncomputably large",
-                 (unsigned int)pngxP->info_ptr->width);
+                 (unsigned int)width);
        
-    return pngxP->info_ptr->width * bytesPerSample * samplesPerPixel;
+    return width * bytesPerSample * samplesPerPixel;
 }
 
 
@@ -297,15 +286,16 @@ allocPngRaster(struct pngx * const pngxP
     unsigned int const lineSize = computePngLineSize(pngxP);
 
     png_byte ** pngImage;
+    png_uint_32 height = png_get_image_height(pngxP->png_ptr, pngxP->info_ptr);
     unsigned int row;
 
-    MALLOCARRAY(pngImage, pngxP->info_ptr->height);
+    MALLOCARRAY(pngImage, height);
 
     if (pngImage == NULL)
         pm_error("couldn't allocate space for %u PNG raster rows",
-                 (unsigned int)pngxP->info_ptr->height);
+                 (unsigned int)height);
 
-    for (row = 0; row < pngxP->info_ptr->height; ++row) {
+    for (row = 0; row < height; ++row) {
         MALLOCARRAY(pngImage[row], lineSize);
         if (pngImage[row] == NULL)
             pm_error("couldn't allocate space for %uth row of PNG raster",
@@ -322,7 +312,7 @@ freePngRaster(png_byte **   const pngRas
 
     unsigned int row;
 
-    for (row = 0; row < pngxP->info_ptr->height; ++row)
+    for (row = 0; row < png_get_image_height(pngxP->png_ptr, pngxP->info_ptr); ++row)
         free(pngRaster[row]);
 
     free(pngRaster);
@@ -349,7 +339,7 @@ readPng(struct pngx * const pngxP,
 
     allocPngRaster(pngxP, &pngRaster);
 
-    if (pngxP->info_ptr->bit_depth < 8)
+    if (png_get_bit_depth(pngxP->png_ptr, pngxP->info_ptr) < 8)
         png_set_packing(pngxP->png_ptr);
 
     png_read_image(pngxP->png_ptr, pngRaster);
@@ -445,31 +435,34 @@ saveText(struct pngx * const pngxP,
          FILE *        const tfP) {
 
     png_info * const info_ptr = pngxP->info_ptr;
-
+    png_text *text;
+    int num_text;
     unsigned int i;
 
-    for (i = 0 ; i < info_ptr->num_text; ++i) {
+    png_get_text(pngxP->png_ptr, info_ptr, &text, &num_text);
+
+    for (i = 0 ; i < num_text; ++i) {
         unsigned int j;
         j = 0;
 
-        while (info_ptr->text[i].key[j] != '\0' &&
-               info_ptr->text[i].key[j] != ' ')
+        while (text[i].key[j] != '\0' &&
+               text[i].key[j] != ' ')
             ++j;    
 
-        if (info_ptr->text[i].key[j] != ' ') {
-            fprintf(tfP, "%s", info_ptr->text[i].key);
-            for (j = strlen (info_ptr->text[i].key); j < 15; ++j)
+        if (text[i].key[j] != ' ') {
+            fprintf(tfP, "%s", text[i].key);
+            for (j = strlen (text[i].key); j < 15; ++j)
                 putc(' ', tfP);
         } else {
-            fprintf(tfP, "\"%s\"", info_ptr->text[i].key);
-            for (j = strlen (info_ptr->text[i].key); j < 13; ++j)
+            fprintf(tfP, "\"%s\"", text[i].key);
+            for (j = strlen (text[i].key); j < 13; ++j)
                 putc(' ', tfP);
         }
         putc(' ', tfP); /* at least one space between key and text */
     
-        for (j = 0; j < info_ptr->text[i].text_length; ++j) {
-            putc(info_ptr->text[i].text[j], tfP);
-            if (info_ptr->text[i].text[j] == '\n') {
+        for (j = 0; j < text[i].text_length; ++j) {
+            putc(text[i].text[j], tfP);
+            if (text[i].text[j] == '\n') {
                 unsigned int k;
                 for (k = 0; k < 16; ++k)
                     putc(' ', tfP);
@@ -489,21 +482,23 @@ showTime(struct pngx * const pngxP) {
         "July", "August", "September", "October", "November", "December"
     };
 
-    if (pngxP->info_ptr->valid & PNG_INFO_tIME) {
-      if (pngxP->info_ptr->mod_time.month < 1 ||
-        pngxP->info_ptr->mod_time.month >= ARRAY_SIZE(month)) {
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_tIME)) {
+      png_timep mod_timep;
+      png_get_tIME(pngxP->png_ptr, pngxP->info_ptr, &mod_timep);
+      if (mod_timep->month < 1 ||
+          mod_timep->month >= ARRAY_SIZE(month)) {
         pm_message("tIME chunk in PNG input is invalid; "
                    "modification time of image is unknown.  "
                    "The month value, which should be in the range "
-                   "1-12, is %u", pngxP->info_ptr->mod_time.month);
+                   "1-12, is %u", mod_timep->month);
       } else
         pm_message("modification time: %02d %s %d %02d:%02d:%02d",
-                   pngxP->info_ptr->mod_time.day,
-                   month[pngxP->info_ptr->mod_time.month],
-                   pngxP->info_ptr->mod_time.year,
-                   pngxP->info_ptr->mod_time.hour,
-                   pngxP->info_ptr->mod_time.minute,
-                   pngxP->info_ptr->mod_time.second);
+                   mod_timep->day,
+                   month[mod_timep->month],
+                   mod_timep->year,
+                   mod_timep->hour,
+                   mod_timep->minute,
+                   mod_timep->second);
     }
 }
 
@@ -516,7 +511,7 @@ dumpPngInfo(struct pngx * const pngxP) {
     const char *type_string;
     const char *filter_string;
 
-    switch (info_ptr->color_type) {
+    switch (png_get_color_type(pngxP->png_ptr, info_ptr)) {
       case PNG_COLOR_TYPE_GRAY:
         type_string = "gray";
         break;
@@ -538,90 +533,106 @@ dumpPngInfo(struct pngx * const pngxP) {
         break;
     }
 
-    switch (info_ptr->filter_type) {
+    switch (png_get_filter_type(pngxP->png_ptr, info_ptr)) {
     case PNG_FILTER_TYPE_BASE:
         asprintfN(&filter_string, "base filter");
         break;
     default:
         asprintfN(&filter_string, "unknown filter type %d", 
-                  info_ptr->filter_type);
+                  png_get_filter_type(pngxP->png_ptr, info_ptr));
     }
 
+    {
+    png_uint_32 width, height;
+    int bit_depth;
+    png_get_IHDR(pngxP->png_ptr, pngxP->info_ptr, &width, &height, &bit_depth, NULL, NULL, NULL, NULL);
     pm_message("reading a %ldw x %ldh image, %d bit%s",
-               info_ptr->width, info_ptr->height,
-               info_ptr->bit_depth, info_ptr->bit_depth > 1 ? "s" : "");
+               (long)width, (long)height,
+               bit_depth, bit_depth > 1 ? "s" : "");
+    }
     pm_message("%s, %s, %s",
                type_string,
-               info_ptr->interlace_type ? 
+               png_get_interlace_type(pngxP->png_ptr, info_ptr) ? 
                "Adam7 interlaced" : "not interlaced",
                filter_string);
+    {
+    png_color_16p bkgp;
+    if(png_get_bKGD(pngxP->png_ptr, info_ptr, &bkgp) && (bkgp != NULL))
     pm_message("background {index, gray, red, green, blue} = "
                "{%d, %d, %d, %d, %d}",
-               info_ptr->background.index,
-               info_ptr->background.gray,
-               info_ptr->background.red,
-               info_ptr->background.green,
-               info_ptr->background.blue);
+               bkgp->index,
+               bkgp->gray,
+               bkgp->red,
+               bkgp->green,
+               bkgp->blue);
+    }
 
     strfree(filter_string);
 
-    if (info_ptr->valid & PNG_INFO_tRNS)
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_tRNS)) {
+        int num_trans;
+        png_get_tRNS(pngxP->png_ptr, info_ptr, NULL, &num_trans, NULL);
         pm_message("tRNS chunk (transparency): %u entries",
-                   info_ptr->num_trans);
-    else
+                   num_trans);
+    } else
         pm_message("tRNS chunk (transparency): not present");
 
-    if (info_ptr->valid & PNG_INFO_gAMA)
-        pm_message("gAMA chunk (image gamma): gamma = %4.2f", info_ptr->gamma);
-    else
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_gAMA)) {
+        double gamma;
+        png_get_gAMA(pngxP->png_ptr, info_ptr, &gamma);
+        pm_message("gAMA chunk (image gamma): gamma = %4.2f", gamma);
+    } else
         pm_message("gAMA chunk (image gamma): not present");
 
-    if (info_ptr->valid & PNG_INFO_sBIT)
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_sBIT))
         pm_message("sBIT chunk: present");
     else
         pm_message("sBIT chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_cHRM)
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_cHRM))
         pm_message("cHRM chunk: present");
     else
         pm_message("cHRM chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_PLTE)
-        pm_message("PLTE chunk: %d entries", info_ptr->num_palette);
-    else
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_PLTE)) {
+        png_colorp palette;
+        int num_palette;
+        png_get_PLTE(pngxP->png_ptr, info_ptr, &palette, &num_palette);
+        pm_message("PLTE chunk: %d entries", num_palette);
+    } else
         pm_message("PLTE chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_bKGD)
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_bKGD))
         pm_message("bKGD chunk: present");
     else
         pm_message("bKGD chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_PLTE)
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_hIST))
         pm_message("hIST chunk: present");
     else
         pm_message("hIST chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_pHYs)
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_pHYs))
         pm_message("pHYs chunk: present");
     else
         pm_message("pHYs chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_oFFs)
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_oFFs))
         pm_message("oFFs chunk: present");
     else
         pm_message("oFFs chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_tIME)
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_tIME))
         pm_message("tIME chunk: present");
     else
         pm_message("tIME chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_pCAL)
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_pCAL))
         pm_message("pCAL chunk: present");
     else
         pm_message("pCAL chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_sRGB)
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_sRGB))
         pm_message("sRGB chunk: present");
     else
         pm_message("sRGB chunk: not present");
@@ -675,7 +686,7 @@ isTransparentColor(pngcolor      const c
            pixels, and just do it ourselves.
         */
     
-        switch (pngxP->info_ptr->color_type) {
+        switch (png_get_color_type(pngxP->png_ptr, pngxP->info_ptr)) {
         case PNG_COLOR_TYPE_GRAY:
             retval = color.r == gamma_correct(transColorP->gray, totalgamma);
             break;
@@ -702,9 +713,11 @@ setupGammaCorrection(struct pngx * const
         *totalgammaP = -1.0;
     else {
         float imageGamma;
-        if (pngxP->info_ptr->valid & PNG_INFO_gAMA)
-            imageGamma = pngxP->info_ptr->gamma;
-        else {
+        if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_gAMA)) {
+            double gamma;
+            png_get_gAMA(pngxP->png_ptr, pngxP->info_ptr, &gamma);
+            imageGamma = gamma;
+	} else {
             if (verbose)
                 pm_message("PNG doesn't specify image gamma.  Assuming 1.0");
             imageGamma = 1.0;
@@ -722,7 +735,7 @@ setupGammaCorrection(struct pngx * const
             /* in case of gamma-corrections, sBIT's as in the
                PNG-file are not valid anymore 
             */
-            pngxP->info_ptr->valid &= ~PNG_INFO_sBIT;
+            png_set_invalid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_sBIT);
             if (verbose)
                 pm_message("image gamma is %4.2f, "
                            "converted for display gamma of %4.2f",
@@ -734,20 +747,23 @@ setupGammaCorrection(struct pngx * const
 
 
 static bool
-paletteHasPartialTransparency(png_info * const info_ptr) {
+paletteHasPartialTransparency(png_struct * const png_ptr, png_info * const info_ptr) {
 
     bool retval;
 
-    if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
-        if (info_ptr->valid & PNG_INFO_tRNS) {
+    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE) {
+        if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) {
             bool foundGray;
             unsigned int i;
+            int num_trans;
+            png_bytep trans_alpha;
+            png_get_tRNS(png_ptr, info_ptr, &trans_alpha, &num_trans, NULL);
             
             for (i = 0, foundGray = FALSE;
-                 i < info_ptr->num_trans && !foundGray;
+                 i < num_trans && !foundGray;
                  ++i) {
-                if (info_ptr->TRANS_ALPHA[i] != 0 &&
-                    info_ptr->TRANS_ALPHA[i] != maxval) {
+                if (trans_alpha[i] != 0 &&
+                    trans_alpha[i] != maxval) {
                     foundGray = TRUE;
                 }
             }
@@ -777,13 +793,14 @@ setupSignificantBits(struct pngx *
     png_info * const info_ptr = pngxP->info_ptr;
 
     /* Initial assumption of maxval */
-    if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+    png_byte color_type = png_get_color_type(pngxP->png_ptr, info_ptr);
+    if (color_type == PNG_COLOR_TYPE_PALETTE) {
         if (alpha == ALPHA_ONLY) {
-            if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-                info_ptr->color_type == PNG_COLOR_TYPE_RGB)
+            if (color_type == PNG_COLOR_TYPE_GRAY ||
+                color_type == PNG_COLOR_TYPE_RGB)
                 /* The alpha mask will be all opaque, so maxval 1 is plenty */
                 *maxvalP = 1;
-            else if (paletteHasPartialTransparency(info_ptr))
+            else if (paletteHasPartialTransparency(pngxP->png_ptr, info_ptr))
                 /* Use same maxval as PNG transparency palette for simplicity*/
                 *maxvalP = 255;
             else
@@ -793,7 +810,7 @@ setupSignificantBits(struct pngx *
             /* Use same maxval as PNG palette for simplicity */
             *maxvalP = 255;
     } else {
-        *maxvalP = (1l << info_ptr->bit_depth) - 1;
+        *maxvalP = (1l << png_get_bit_depth(pngxP->png_ptr, info_ptr)) - 1;
     }
 
     /* sBIT handling is very tricky. If we are extracting only the
@@ -806,20 +823,25 @@ setupSignificantBits(struct pngx *
        is used 
     */
     
-    if (info_ptr->valid & PNG_INFO_sBIT) {
+    if (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_sBIT)) {
+        png_color_8p sig_bit;
+        png_get_sBIT(pngxP->png_ptr, info_ptr, &sig_bit);
         switch (alpha) {
         case ALPHA_MIX:
-            if (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
-                info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+            if (color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+                color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
                 break;
-            if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
-                (info_ptr->valid & PNG_INFO_tRNS)) {
+            if (color_type == PNG_COLOR_TYPE_PALETTE &&
+                (png_get_valid(pngxP->png_ptr, info_ptr, PNG_INFO_tRNS))) {
 
+                png_bytep trans_alpha;
+                int num_trans;
                 bool trans_mix;
                 unsigned int i;
                 trans_mix = TRUE;
-                for (i = 0; i < info_ptr->num_trans; ++i)
-                    if (info_ptr->TRANS_ALPHA[i] != 0 && info_ptr->TRANS_ALPHA[i] != 255) {
+                png_get_tRNS(pngxP->png_ptr, info_ptr, &trans_alpha, &num_trans, NULL);
+                for (i = 0; i < num_trans; ++i)
+                    if (trans_alpha[i] != 0 && trans_alpha[i] != 255) {
                         trans_mix = FALSE;
                         break;
                     }
@@ -830,70 +852,73 @@ setupSignificantBits(struct pngx *
             /* else fall though to normal case */
 
         case ALPHA_NONE:
-            if ((info_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
-                 info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
-                 info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
-                (info_ptr->sig_bit.red != info_ptr->sig_bit.green ||
-                 info_ptr->sig_bit.red != info_ptr->sig_bit.blue) &&
+            if ((color_type == PNG_COLOR_TYPE_PALETTE ||
+                 color_type == PNG_COLOR_TYPE_RGB ||
+                 color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
+                (sig_bit->red != sig_bit->green ||
+                 sig_bit->red != sig_bit->blue) &&
                 alpha == ALPHA_NONE) {
                 pm_message("This program cannot handle "
                            "different bit depths for color channels");
                 pm_message("writing file with %d bit resolution",
-                           info_ptr->bit_depth);
+                           png_get_bit_depth(pngxP->png_ptr, info_ptr));
                 *errorLevelP = PNMTOPNG_WARNING_LEVEL;
             } else {
-                if ((info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) &&
-                    (info_ptr->sig_bit.red < 255)) {
+                if ((color_type == PNG_COLOR_TYPE_PALETTE) &&
+                    (sig_bit->red < 255)) {
                     unsigned int i;
-                    for (i = 0; i < info_ptr->num_palette; ++i) {
-                        info_ptr->palette[i].red   >>=
-                            (8 - info_ptr->sig_bit.red);
-                        info_ptr->palette[i].green >>=
-                            (8 - info_ptr->sig_bit.green);
-                        info_ptr->palette[i].blue  >>=
-                            (8 - info_ptr->sig_bit.blue);
+                    png_colorp palette;
+                    int num_palette;
+                    png_get_PLTE(pngxP->png_ptr, info_ptr, &palette, &num_palette);
+                    for (i = 0; i < num_palette; ++i) {
+                        palette[i].red   >>=
+                            (8 - sig_bit->red);
+                        palette[i].green >>=
+                            (8 - sig_bit->green);
+                        palette[i].blue  >>=
+                            (8 - sig_bit->blue);
                     }
-                    *maxvalP = (1l << info_ptr->sig_bit.red) - 1;
+                    *maxvalP = (1l << sig_bit->red) - 1;
                     if (verbose)
                         pm_message ("image has fewer significant bits, "
                                     "writing file with %d bits per channel", 
-                                    info_ptr->sig_bit.red);
+                                    sig_bit->red);
                 } else
-                    if ((info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
-                         info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
-                        (info_ptr->sig_bit.red < info_ptr->bit_depth)) {
-                        png_set_shift(pngxP->png_ptr, &(info_ptr->sig_bit));
-                        *maxvalP = (1l << info_ptr->sig_bit.red) - 1;
+                    if ((color_type == PNG_COLOR_TYPE_RGB ||
+                         color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
+                        (sig_bit->red < png_get_bit_depth(pngxP->png_ptr, info_ptr))) {
+                        png_set_shift(pngxP->png_ptr, sig_bit);
+                        *maxvalP = (1l << sig_bit->red) - 1;
                         if (verbose)
                             pm_message("image has fewer significant bits, "
                                        "writing file with %d "
                                        "bits per channel", 
-                                       info_ptr->sig_bit.red);
+                                       sig_bit->red);
                     } else 
-                        if ((info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-                             info_ptr->color_type ==
+                        if ((color_type == PNG_COLOR_TYPE_GRAY ||
+                             color_type ==
                                  PNG_COLOR_TYPE_GRAY_ALPHA) &&
-                            (info_ptr->sig_bit.gray < info_ptr->bit_depth)) {
-                            png_set_shift(pngxP->png_ptr, &info_ptr->sig_bit);
-                            *maxvalP = (1l << info_ptr->sig_bit.gray) - 1;
+                            (sig_bit->gray < png_get_bit_depth(pngxP->png_ptr, info_ptr))) {
+                            png_set_shift(pngxP->png_ptr, sig_bit);
+                            *maxvalP = (1l << sig_bit->gray) - 1;
                             if (verbose)
                                 pm_message("image has fewer significant bits, "
                                            "writing file with %d bits",
-                                           info_ptr->sig_bit.gray);
+                                           sig_bit->gray);
                         }
             }
             break;
 
         case ALPHA_ONLY:
-            if ((info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
-                 info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) && 
-                (info_ptr->sig_bit.gray < info_ptr->bit_depth)) {
-                png_set_shift(pngxP->png_ptr, &info_ptr->sig_bit);
+            if ((color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+                 color_type == PNG_COLOR_TYPE_GRAY_ALPHA) && 
+                (sig_bit->gray < png_get_bit_depth(pngxP->png_ptr, info_ptr))) {
+                png_set_shift(pngxP->png_ptr, sig_bit);
                 if (verbose)
                     pm_message ("image has fewer significant bits, "
                                 "writing file with %d bits", 
-                                info_ptr->sig_bit.alpha);
-                *maxvalP = (1l << info_ptr->sig_bit.alpha) - 1;
+                                sig_bit->alpha);
+                *maxvalP = (1l << sig_bit->alpha) - 1;
             }
             break;
 
@@ -908,18 +933,23 @@ imageHasColor(struct pngx * const pngxP)
 
     bool retval;
 
-    if (pngxP->info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-        pngxP->info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+    png_byte color_type = png_get_color_type(pngxP->png_ptr, pngxP->info_ptr);
+    if (color_type == PNG_COLOR_TYPE_GRAY ||
+        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
 
         retval = FALSE;
-    else if (pngxP->info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+    else if (color_type == PNG_COLOR_TYPE_PALETTE) {
         bool foundColor;
         unsigned int i;
+        png_colorp palette;
+        int num_palette;
+
+        png_get_PLTE(pngxP->png_ptr, pngxP->info_ptr, &palette, &num_palette);
             
         for (i = 0, foundColor = FALSE;
-             i < pngxP->info_ptr->num_palette && !foundColor;
+             i < num_palette && !foundColor;
              ++i) {
-            if (iscolor(pngxP->info_ptr->palette[i]))
+            if (iscolor(palette[i]))
                 foundColor = TRUE;
         }
         retval = foundColor;
@@ -974,19 +1004,24 @@ getBackgroundColor(struct pngx * const p
         bgColorP->g = PPM_GETG(backcolor);
         bgColorP->b = PPM_GETB(backcolor);
 
-    } else if (pngxP->info_ptr->valid & PNG_INFO_bKGD) {
+    } else if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_bKGD)) {
+        png_color_16p background;
+        png_get_bKGD(pngxP->png_ptr, pngxP->info_ptr, &background);
         /* didn't manage to get libpng to work (bugs?) concerning background
            processing, therefore we do our own.
         */
-        switch (pngxP->info_ptr->color_type) {
+        switch (png_get_color_type(pngxP->png_ptr, pngxP->info_ptr)) {
         case PNG_COLOR_TYPE_GRAY:
         case PNG_COLOR_TYPE_GRAY_ALPHA:
             bgColorP->r = bgColorP->g = bgColorP->b = 
-                gamma_correct(pngxP->info_ptr->background.gray, totalgamma);
+                gamma_correct(background->gray, totalgamma);
             break;
         case PNG_COLOR_TYPE_PALETTE: {
+            png_colorp palette;
+            int num_palette;
+            png_get_PLTE(pngxP->png_ptr, pngxP->info_ptr, &palette, &num_palette);
             png_color const rawBgcolor = 
-                pngxP->info_ptr->palette[pngxP->info_ptr->background.index];
+                palette[background->index];
             bgColorP->r = gamma_correct(rawBgcolor.red, totalgamma);
             bgColorP->g = gamma_correct(rawBgcolor.green, totalgamma);
             bgColorP->b = gamma_correct(rawBgcolor.blue, totalgamma);
@@ -994,7 +1029,7 @@ getBackgroundColor(struct pngx * const p
         break;
         case PNG_COLOR_TYPE_RGB:
         case PNG_COLOR_TYPE_RGB_ALPHA: {
-            png_color_16 const rawBgcolor = pngxP->info_ptr->background;
+            png_color_16 const rawBgcolor = *background;
             
             bgColorP->r = gamma_correct(rawBgcolor.red,   totalgamma);
             bgColorP->g = gamma_correct(rawBgcolor.green, totalgamma);
@@ -1013,10 +1048,12 @@ static void
 warnNonsquarePixels(struct pngx * const pngxP,
                     int *         const errorLevelP) {
 
-    if (pngxP->info_ptr->valid & PNG_INFO_pHYs) {
+    if (png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_pHYs)) {
+        png_uint_32 x_pixels_per_unit, y_pixels_per_unit;
+        png_get_pHYs(pngxP->png_ptr, pngxP->info_ptr, &x_pixels_per_unit, &y_pixels_per_unit, NULL);
         float const r =
-            (float)pngxP->info_ptr->x_pixels_per_unit /
-            pngxP->info_ptr->y_pixels_per_unit;
+            (float)x_pixels_per_unit /
+            y_pixels_per_unit;
 
         if (r != 1.0) {
             pm_message ("warning - non-square pixels; "
@@ -1030,7 +1067,7 @@ warnNonsquarePixels(struct pngx * const
 
 
 
-#define GET_PNG_VAL(p) get_png_val(&(p), pngxP->info_ptr->bit_depth)
+#define GET_PNG_VAL(p) get_png_val(&(p), png_get_bit_depth(pngxP->png_ptr, pngxP->info_ptr))
 
 
 
@@ -1048,8 +1085,8 @@ makeXelRow(xel *               const xel
     unsigned int col;
 
     pngPixelP = &pngRasterRow[0];  /* initial value */
-    for (col = 0; col < pngxP->info_ptr->width; ++col) {
-        switch (pngxP->info_ptr->color_type) {
+    for (col = 0; col < png_get_image_width(pngxP->png_ptr, pngxP->info_ptr); ++col) {
+        switch (png_get_color_type(pngxP->png_ptr, pngxP->info_ptr)) {
         case PNG_COLOR_TYPE_GRAY: {
             pngcolor fgColor;
             fgColor.r = fgColor.g = fgColor.b = GET_PNG_VAL(pngPixelP);
@@ -1071,7 +1108,15 @@ makeXelRow(xel *               const xel
 
         case PNG_COLOR_TYPE_PALETTE: {
             png_uint_16 const index        = GET_PNG_VAL(pngPixelP);
-            png_color   const paletteColor = pngxP->info_ptr->palette[index];
+            png_color   paletteColor;
+            png_colorp  palette;
+	    png_bytep   trans_alpha;
+            int         num_palette, num_trans;
+	    bool        trans_valid = png_get_valid(pngxP->png_ptr, pngxP->info_ptr, PNG_INFO_tRNS);
+            png_get_PLTE(pngxP->png_ptr, pngxP->info_ptr, &palette, &num_palette);
+	    if (trans_valid)
+	        png_get_tRNS(pngxP->png_ptr, pngxP->info_ptr, &trans_alpha, &num_trans, NULL);
+            paletteColor = palette[index];
 
             pngcolor fgColor;
 
@@ -1080,9 +1125,9 @@ makeXelRow(xel *               const xel
             fgColor.b = paletteColor.blue;
 
             setXel(&xelrow[col], fgColor, bgColor, alphaHandling,
-                   (pngxP->info_ptr->valid & PNG_INFO_tRNS) &&
-                   index < pngxP->info_ptr->num_trans ?
-                   pngxP->info_ptr->TRANS_ALPHA[index] : maxval);
+                   trans_valid &&
+                   index < num_trans ?
+                   trans_alpha[index] : maxval);
         }
         break;
                 
@@ -1112,13 +1157,20 @@ makeXelRow(xel *               const xel
 
         default:
             pm_error("unknown PNG color type: %d",
-                     pngxP->info_ptr->color_type);
+                     png_get_color_type(pngxP->png_ptr, pngxP->info_ptr));
         }
     }
 }
 
 
 
+static png_bytep get_png_trans_alpha(struct pngx * const pngxP)
+{
+    png_bytep trans_alpha;
+    png_get_tRNS(pngxP->png_ptr, pngxP->info_ptr, &trans_alpha, NULL, NULL);
+    return trans_alpha;
+}
+ 
 static void
 writePnm(FILE *              const ofP,
          xelval              const maxval,
@@ -1142,6 +1194,8 @@ writePnm(FILE *              const ofP,
 
     xel * xelrow;
     unsigned int row;
+    png_uint_32 width = png_get_image_width(pngxP->png_ptr, pngxP->info_ptr),
+                height = png_get_image_height(pngxP->png_ptr, pngxP->info_ptr);
 
     if (verbose)
         pm_message("writing a %s file (maxval=%u)",
@@ -1151,17 +1205,17 @@ writePnm(FILE *              const ofP,
                    "UNKNOWN!", 
                    maxval);
     
-    xelrow = pnm_allocrow(pngxP->info_ptr->width);
+    xelrow = pnm_allocrow(width);
 
     pnm_writepnminit(stdout,
-                     pngxP->info_ptr->width, pngxP->info_ptr->height, maxval,
+                     width, height, maxval,
                      pnmType, plainFalse);
 
-    for (row = 0; row < pngxP->info_ptr->height; ++row) {
+    for (row = 0; row < height; ++row) {
         makeXelRow(xelrow, maxval, pnmType, pngxP, pngRaster[row], bgColor,
                    alphaHandling, totalgamma);
 
-        pnm_writepnmrow(ofP, xelrow, pngxP->info_ptr->width, maxval,
+        pnm_writepnmrow(ofP, xelrow, width, maxval,
                         pnmType, plainFalse);
     }
     pnm_freerow (xelrow);
--- netpbm-10.35.83/converter/other/pngtxt.c.orig	2006-08-19 05:12:28.000000000 +0200
+++ netpbm-10.35.83/converter/other/pngtxt.c	2012-01-29 09:59:22.463431985 +0100
@@ -240,7 +240,8 @@
 
 
 void 
-pnmpng_read_text (png_info * const info_ptr, 
+pnmpng_read_text (png_struct * const png_ptr,
+                  png_info * const info_ptr, 
                   FILE *     const tfp, 
                   bool       const ztxt,
                   bool       const verbose) {
@@ -250,15 +251,16 @@
     unsigned int commentIdx;
     bool noCommentsYet;
     bool eof;
+    png_textp text;
     unsigned int allocatedComments;
-        /* Number of entries currently allocated for the info_ptr->text
+        /* Number of entries currently allocated for the text
            array 
         */
 
     allocatedComments = 256;  /* initial value */
 
-    MALLOCARRAY(info_ptr->text, allocatedComments);
-    if (info_ptr->text == NULL) 
+    MALLOCARRAY(text, allocatedComments);
+    if (text == NULL) 
         pm_error("unable to allocate memory for comment array");
 
     commentIdx = 0;
@@ -273,7 +275,7 @@
             if (lineLength == 0) {
                 /* skip this empty line */
             } else {
-                handleArrayAllocation(&info_ptr->text, &allocatedComments,
+                handleArrayAllocation(&text, &allocatedComments,
                                       commentIdx);
                 if ((textline[0] != ' ') && (textline[0] != '\t')) {
                     /* Line doesn't start with white space, which
@@ -285,7 +287,7 @@
                         ++commentIdx;
                     noCommentsYet = FALSE;
 
-                    startComment(&info_ptr->text[commentIdx], 
+                    startComment(&text[commentIdx], 
                                  textline, lineLength, ztxt);
                 } else {
                     /* Line starts with whitespace, which means it is
@@ -295,20 +297,20 @@
                         pm_error("Invalid comment file format: "
                                  "first line is a continuation line! "
                                  "(It starts with whitespace)");
-                    continueComment(&info_ptr->text[commentIdx], 
+                    continueComment(&text[commentIdx], 
                                     textline, lineLength);
                 }
             }
             strfree(textline);
         }
     } 
-    if (noCommentsYet)
-        info_ptr->num_text = 0;
-    else
-        info_ptr->num_text = commentIdx + 1;
+    if (!noCommentsYet)
+        png_set_text(png_ptr, info_ptr, text, commentIdx + 1);
 
     if (verbose)
-        pm_message("%d comments placed in text chunk", info_ptr->num_text);
+        pm_message("%d comments placed in text chunk", commentIdx + 1);
+
+    free(text);
 }
 
 
--- netpbm-10.35.83/converter/other/pngtxt.h.orig	2006-08-19 05:12:28.000000000 +0200
+++ netpbm-10.35.83/converter/other/pngtxt.h	2012-01-29 09:59:59.566766561 +0100
@@ -5,7 +5,8 @@
 #include <png.h>
 
 void 
-pnmpng_read_text (png_info * const info_ptr, 
+pnmpng_read_text (png_struct * const png_ptr,
+                  png_info * const info_ptr, 
                   FILE *     const tfp, 
                   bool const ztxt,
                   bool const verbose);
--- netpbm-10.35.83/converter/other/pamrgbatopng.c.orig	2006-08-19 05:12:28.000000000 +0200
+++ netpbm-10.35.83/converter/other/pamrgbatopng.c	2012-01-29 14:02:47.790587693 +0100
@@ -101,10 +101,9 @@
     if (!infoP)
         pm_error("Could not allocate PNG info structure");
     else {
-        infoP->width      = pamP->width;
-        infoP->height     = pamP->height;
-        infoP->bit_depth  = 8;
-        infoP->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
+        png_set_IHDR(pngP, infoP,
+                     pamP->width, pamP->height,
+		     8, PNG_COLOR_TYPE_RGB_ALPHA, 0, 0, 0);
         
         png_init_io(pngP, ofP);
 
--- netpbm-10.35.90/converter/other/tifftopnm.c~	2006-08-19 05:12:28.000000000 +0200
+++ netpbm-10.35.90/converter/other/tifftopnm.c	2013-10-31 17:58:49.296479893 +0100
@@ -902,14 +902,14 @@
                 
                 ok = TIFFRGBAImageBegin(&img, tif, stopOnErrorFalse, emsg) ;
                 if (!ok) {
-                    pm_message(emsg);
+                    pm_message("%s", emsg);
                     *statusP = CONV_FAILED;
                 } else {
                     int ok;
                     ok = TIFFRGBAImageGet(&img, raster, cols, rows);
                     TIFFRGBAImageEnd(&img) ;
                     if (!ok) {
-                        pm_message(emsg);
+                        pm_message("%s", emsg);
                         *statusP = CONV_FAILED;
                     } else {
                         *statusP = CONV_DONE;
--- netpbm-10.35.90/converter/other/tifftopnm.c~	2013-10-31 17:59:04.000000000 +0100
+++ netpbm-10.35.90/converter/other/tifftopnm.c	2013-10-31 18:00:05.761780998 +0100
@@ -882,7 +882,7 @@
         int ok;
         ok = TIFFRGBAImageOK(tif, emsg);
         if (!ok) {
-            pm_message(emsg);
+            pm_message("%s", emsg);
             *statusP = CONV_UNABLE;
         } else {
             uint32* raster ;
--- netpbm-10.35.90/converter/other/fiasco/pnmtofiasco.c~	2006-08-19 05:12:28.000000000 +0200
+++ netpbm-10.35.90/converter/other/fiasco/pnmtofiasco.c	2013-10-31 18:02:13.731936837 +0100
@@ -176,7 +176,7 @@
       return 0;
    else
    {
-      fprintf (stderr, fiasco_get_error_message ());
+      fprintf (stderr, "%s", fiasco_get_error_message ());
       fprintf (stderr, "\n");
       return 1;
    }
--- netpbm-10.35.90/converter/other/fiasco/params.c~	2006-08-19 05:12:28.000000000 +0200
+++ netpbm-10.35.90/converter/other/fiasco/params.c	2013-10-31 18:05:00.869560937 +0100
@@ -652,7 +652,7 @@
    fprintf (stderr, "Usage: %s [OPTION]...%s\n", progname,
 	    non_opt_string ? non_opt_string : " ");
    if (synopsis != NULL)
-      fprintf (stderr, synopsis);
+      fprintf (stderr, "%s", synopsis);
    fprintf (stderr, "\n\n");
    fprintf (stderr, "Mandatory or optional arguments to long options "
 	    "are mandatory or optional\nfor short options too. "
--- netpbm-10.47.61/converter/pbm/cmuwmtopbm.c.orig	2016-03-27 03:38:28.000000000 +0200
+++ netpbm-10.47.61/converter/pbm/cmuwmtopbm.c	2016-06-08 20:43:31.277330446 +0200
@@ -39,20 +39,20 @@
 
     rc = pm_readbiglong(ifP, &l);
     if (rc == -1 )
-        pm_error(initReadError);
+        pm_error("%s", initReadError);
     if ((uint32_t)l != CMUWM_MAGIC)
         pm_error("bad magic number in CMU window manager file");
     rc = pm_readbiglong(ifP, &l);
     if (rc == -1)
-        pm_error(initReadError);
+        pm_error("%s", initReadError);
     *colsP = l;
     rc = pm_readbiglong(ifP, &l);
     if (rc == -1 )
-        pm_error(initReadError);
+        pm_error("%s", initReadError);
     *rowsP = l;
     rc = pm_readbigshort(ifP, &s);
     if (rc == -1)
-        pm_error(initReadError);
+        pm_error("%s", initReadError);
     *depthP = s;
 }
 
--- netpbm-10.47.61/converter/pbm/pbmtocmuwm.c.orig	2016-03-27 03:38:28.000000000 +0200
+++ netpbm-10.47.61/converter/pbm/pbmtocmuwm.c	2016-06-08 20:48:55.797316874 +0200
@@ -31,16 +31,16 @@
 
     rc = pm_writebiglong(stdout, CMUWM_MAGIC);
     if (rc == -1)
-        pm_error(initWriteError);
+        pm_error("%s", initWriteError);
     rc = pm_writebiglong(stdout, cols);
     if (rc == -1)
-        pm_error(initWriteError);
+        pm_error("%s", initWriteError);
     rc = pm_writebiglong(stdout, rows);
     if (rc == -1)
-        pm_error(initWriteError);
+        pm_error("%s", initWriteError);
     rc = pm_writebigshort(stdout, (short) 1);
     if (rc == -1)
-        pm_error(initWriteError);
+        pm_error("%s", initWriteError);
 }
 
 
--- netpbm-10.47.61/converter/other/pngtopam.c.orig	2016-03-27 03:38:28.000000000 +0200
+++ netpbm-10.47.61/converter/other/pngtopam.c	2016-06-10 21:50:14.703243717 +0200
@@ -30,14 +30,6 @@
 #include "shhopt.h"
 #include "pam.h"
 
-/* A hack until we can remove direct access to png_info from the program */
-#if PNG_LIBPNG_VER >= 10400
-#define trans_values trans_color
-#define TRANS_ALPHA trans_alpha
-#else
-#define TRANS_ALPHA trans
-#endif
-
 typedef struct _jmpbuf_wrapper {
   jmp_buf jmpbuf;
 } jmpbuf_wrapper;
@@ -268,28 +260,31 @@ static int iscolor (png_color c)
   return c.red != c.green || c.green != c.blue;
 }
 
-static void save_text (png_info *info_ptr, FILE *tfp)
+static void save_text (png_struct *png_ptr, png_info *info_ptr, FILE *tfp)
 {
   int i, j, k;
+  png_text *text;
+  int num_text;
 
-  for (i = 0 ; i < info_ptr->num_text ; i++) {
+  png_get_text(png_ptr, info_ptr, &text, &num_text);
+  for (i = 0 ; i < num_text ; i++) {
     j = 0;
-    while (info_ptr->text[i].key[j] != '\0' && info_ptr->text[i].key[j] != ' ')
+    while (text[i].key[j] != '\0' && text[i].key[j] != ' ')
       j++;    
-    if (info_ptr->text[i].key[j] != ' ') {
-      fprintf (tfp, "%s", info_ptr->text[i].key);
-      for (j = strlen (info_ptr->text[i].key) ; j < 15 ; j++)
+    if (text[i].key[j] != ' ') {
+      fprintf (tfp, "%s", text[i].key);
+      for (j = strlen (text[i].key) ; j < 15 ; j++)
         putc (' ', tfp);
     } else {
-      fprintf (tfp, "\"%s\"", info_ptr->text[i].key);
-      for (j = strlen (info_ptr->text[i].key) ; j < 13 ; j++)
+      fprintf (tfp, "\"%s\"", text[i].key);
+      for (j = strlen (text[i].key) ; j < 13 ; j++)
         putc (' ', tfp);
     }
     putc (' ', tfp); /* at least one space between key and text */
     
-    for (j = 0 ; j < info_ptr->text[i].text_length ; j++) {
-      putc (info_ptr->text[i].text[j], tfp);
-      if (info_ptr->text[i].text[j] == '\n')
+    for (j = 0 ; j < text[i].text_length ; j++) {
+      putc (text[i].text[j], tfp);
+      if (text[i].text[j] == '\n')
         for (k = 0 ; k < 16 ; k++)
           putc ((int)' ', tfp);
     }
@@ -297,25 +292,28 @@ static void save_text (png_info *info_pt
   }
 }
 
-static void show_time (png_info *info_ptr)
+static void show_time (png_struct *png_ptr, png_info *info_ptr)
 {
     static const char * const month[] = {
         "", "January", "February", "March", "April", "May", "June",
         "July", "August", "September", "October", "November", "December"
     };
 
-  if (info_ptr->valid & PNG_INFO_tIME) {
-    if (info_ptr->mod_time.month < 1 ||
-      info_ptr->mod_time.month >= ARRAY_SIZE(month)) {
+  if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tIME)) {
+    png_timep mod_timep;
+
+    png_get_tIME(png_ptr, info_ptr, &mod_timep);
+    if (mod_timep->month < 1 ||
+      mod_timep->month >= ARRAY_SIZE(month)) {
       pm_message("tIME chunk in PNG input is invalid; "
                  "modification time of image is unknown.  "
                  "The month value, which should be in the range "
-                 "1-12, is %u", info_ptr->mod_time.month);
+                 "1-12, is %u", mod_timep->month);
     } else
     pm_message ("modification time: %02d %s %d %02d:%02d:%02d",
-                info_ptr->mod_time.day, month[info_ptr->mod_time.month],
-                info_ptr->mod_time.year, info_ptr->mod_time.hour,
-                info_ptr->mod_time.minute, info_ptr->mod_time.second);
+                mod_timep->day, month[mod_timep->month],
+                mod_timep->year, mod_timep->hour,
+                mod_timep->minute, mod_timep->second);
   }
 }
 
@@ -346,12 +344,12 @@ static void pngtopnm_error_handler (png_
 
 
 static void
-dump_png_info(png_info *info_ptr) {
+dump_png_info(png_struct *png_ptr, png_info *info_ptr) {
 
     const char *type_string;
     const char *filter_string;
 
-    switch (info_ptr->color_type) {
+    switch (png_get_color_type(png_ptr, info_ptr)) {
       case PNG_COLOR_TYPE_GRAY:
         type_string = "gray";
         break;
@@ -373,90 +371,106 @@ dump_png_info(png_info *info_ptr) {
         break;
     }
 
-    switch (info_ptr->filter_type) {
+    switch (png_get_filter_type(png_ptr, info_ptr)) {
     case PNG_FILTER_TYPE_BASE:
         asprintfN(&filter_string, "base filter");
         break;
     default:
         asprintfN(&filter_string, "unknown filter type %d", 
-                  info_ptr->filter_type);
+                  png_get_filter_type(png_ptr, info_ptr));
     }
 
+    {
+    png_uint_32 width, height;
+    int bit_depth;
+    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, NULL, NULL, NULL, NULL);
     pm_message("reading a %ldw x %ldh image, %d bit%s",
-               info_ptr->width, info_ptr->height,
-               info_ptr->bit_depth, info_ptr->bit_depth > 1 ? "s" : "");
+               (long)width, (long)height,
+               bit_depth, bit_depth > 1 ? "s" : "");
+    }
     pm_message("%s, %s, %s",
                type_string,
-               info_ptr->interlace_type ? 
+               png_get_interlace_type(png_ptr, info_ptr) ? 
                "Adam7 interlaced" : "not interlaced",
                filter_string);
+    {
+    png_color_16p bkgp;
+    if(png_get_bKGD(png_ptr, info_ptr, &bkgp) && (bkgp != NULL))
     pm_message("background {index, gray, red, green, blue} = "
                "{%d, %d, %d, %d, %d}",
-               info_ptr->background.index,
-               info_ptr->background.gray,
-               info_ptr->background.red,
-               info_ptr->background.green,
-               info_ptr->background.blue);
+               bkgp->index,
+               bkgp->gray,
+               bkgp->red,
+               bkgp->green,
+               bkgp->blue);
+    }
 
     strfree(filter_string);
 
-    if (info_ptr->valid & PNG_INFO_tRNS)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) {
+        int num_trans;
+        png_get_tRNS(png_ptr, info_ptr, NULL, &num_trans, NULL);
         pm_message("tRNS chunk (transparency): %u entries",
-                   info_ptr->num_trans);
-    else
+                   num_trans);
+    } else
         pm_message("tRNS chunk (transparency): not present");
 
-    if (info_ptr->valid & PNG_INFO_gAMA)
-        pm_message("gAMA chunk (image gamma): gamma = %4.2f", info_ptr->gamma);
-    else
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA)) {
+        double gamma;
+        png_get_gAMA(png_ptr, info_ptr, &gamma);
+        pm_message("gAMA chunk (image gamma): gamma = %4.2f", gamma);
+    } else
         pm_message("gAMA chunk (image gamma): not present");
 
-    if (info_ptr->valid & PNG_INFO_sBIT)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT))
         pm_message("sBIT chunk: present");
     else
         pm_message("sBIT chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_cHRM)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM))
         pm_message("cHRM chunk: present");
     else
         pm_message("cHRM chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_PLTE)
-        pm_message("PLTE chunk: %d entries", info_ptr->num_palette);
-    else
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_PLTE)) {
+        png_colorp palette;
+        int num_palette;
+        png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);
+        pm_message("PLTE chunk: %d entries", num_palette);
+    } else
         pm_message("PLTE chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_bKGD)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))
         pm_message("bKGD chunk: present");
     else
         pm_message("bKGD chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_hIST)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_hIST))
         pm_message("hIST chunk: present");
     else
         pm_message("hIST chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_pHYs)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_pHYs))
         pm_message("pHYs chunk: present");
     else
         pm_message("pHYs chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_oFFs)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_oFFs))
         pm_message("oFFs chunk: present");
     else
         pm_message("oFFs chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_tIME)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tIME))
         pm_message("tIME chunk: present");
     else
         pm_message("tIME chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_pCAL)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_pCAL))
         pm_message("pCAL chunk: present");
     else
         pm_message("pCAL chunk: not present");
 
-    if (info_ptr->valid & PNG_INFO_sRGB)
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB))
         pm_message("sRGB chunk: present");
     else
         pm_message("sRGB chunk: not present");
@@ -465,44 +479,50 @@ dump_png_info(png_info *info_ptr) {
 
 
 static unsigned int
-computePngLineSize(png_info * const pngInfoP) {
-
-    unsigned int const bytesPerSample = pngInfoP->bit_depth == 16 ? 2 : 1;
+computePngLineSize(png_struct * const pngP, png_info * const pngInfoP) {
 
+    png_uint_32 width;
+    int bit_depth, color_type;
+    unsigned int bytesPerSample;
     unsigned int samplesPerPixel;
 
-    switch (pngInfoP->color_type) {
+    png_get_IHDR(pngP, pngInfoP, &width, NULL, &bit_depth, &color_type, NULL, NULL, NULL);
+    bytesPerSample = (bit_depth == 16) ? 2 : 1;
+
+    switch (color_type) {
     case PNG_COLOR_TYPE_GRAY_ALPHA: samplesPerPixel = 2; break;
     case PNG_COLOR_TYPE_RGB:        samplesPerPixel = 3; break;
     case PNG_COLOR_TYPE_RGB_ALPHA:  samplesPerPixel = 4; break;
     default:                        samplesPerPixel = 1;
     }
 
-    if (UINT_MAX / bytesPerSample / samplesPerPixel < pngInfoP->width)
+    if (UINT_MAX / bytesPerSample / samplesPerPixel < width)
         pm_error("Width %u of PNG is uncomputably large",
-                 (unsigned int)pngInfoP->width);
+                 (unsigned int)width);
        
-    return pngInfoP->width * bytesPerSample * samplesPerPixel;
+    return width * bytesPerSample * samplesPerPixel;
 }
 
 
 
 static void
-allocPngRaster(png_info *   const pngInfoP,
+allocPngRaster(png_struct * const pngP,
+               png_info *   const pngInfoP,
                png_byte *** const pngImageP) {
 
-    unsigned int const lineSize = computePngLineSize(pngInfoP);
+    unsigned int const lineSize = computePngLineSize(pngP, pngInfoP);
 
     png_byte ** pngImage;
+    png_uint_32 height = png_get_image_height(pngP, pngInfoP);
     unsigned int row;
 
-    MALLOCARRAY(pngImage, pngInfoP->height);
+    MALLOCARRAY(pngImage, height);
 
     if (pngImage == NULL)
         pm_error("couldn't allocate space for %u PNG raster rows",
-                 (unsigned int)pngInfoP->height);
+                 (unsigned int)height);
 
-    for (row = 0; row < pngInfoP->height; ++row) {
+    for (row = 0; row < height; ++row) {
         MALLOCARRAY(pngImage[row], lineSize);
         if (pngImage[row] == NULL)
             pm_error("couldn't allocate space for %uth row of PNG raster",
@@ -515,11 +535,12 @@ allocPngRaster(png_info *   const pngInf
 
 static void
 freePngRaster(png_byte ** const pngRaster,
+              png_struct* const pngP,
               png_info *  const pngInfoP) {
 
     unsigned int row;
 
-    for (row = 0; row < pngInfoP->height; ++row)
+    for (row = 0; row < png_get_image_height(pngP, pngInfoP); ++row)
         free(pngRaster[row]);
 
     free(pngRaster);
@@ -529,6 +550,7 @@ freePngRaster(png_byte ** const pngRaste
 
 static bool
 isTransparentColor(pngcolor   const color,
+                   png_struct * const pngP,
                    png_info * const pngInfoP,
                    double     const totalgamma) {
 /*----------------------------------------------------------------------------
@@ -539,8 +561,9 @@ isTransparentColor(pngcolor   const colo
 -----------------------------------------------------------------------------*/
     bool retval;
 
-    if (pngInfoP->valid & PNG_INFO_tRNS) {
-        const png_color_16 * const transColorP = &pngInfoP->trans_values;
+    if (png_get_valid(pngP, pngInfoP, PNG_INFO_tRNS)) {
+        png_color_16 * transColorP;
+	png_get_tRNS(pngP, pngInfoP, NULL, NULL, &transColorP);
 
         /* It seems odd that libpng lets you get gamma-corrected pixel
            values, but not gamma-corrected transparency or background
@@ -556,7 +579,7 @@ isTransparentColor(pngcolor   const colo
            pixels, and just do it ourselves.
         */
     
-        switch (pngInfoP->color_type) {
+        switch (png_get_color_type(pngP, pngInfoP)) {
         case PNG_COLOR_TYPE_GRAY:
             retval = color.r == gamma_correct(transColorP->gray, totalgamma);
             break;
@@ -603,9 +626,11 @@ setupGammaCorrection(png_struct * const
         *totalgammaP = -1.0;
     else {
         float imageGamma;
-        if (info_ptr->valid & PNG_INFO_gAMA)
-            imageGamma = info_ptr->gamma;
-        else {
+        if (png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA)) {
+            double gamma;
+            png_get_gAMA(png_ptr, info_ptr, &gamma);
+            imageGamma = gamma;
+	} else {
             if (verbose)
                 pm_message("PNG doesn't specify image gamma.  Assuming 1.0");
             imageGamma = 1.0;
@@ -623,7 +648,7 @@ setupGammaCorrection(png_struct * const
             /* in case of gamma-corrections, sBIT's as in the
                PNG-file are not valid anymore 
             */
-            info_ptr->valid &= ~PNG_INFO_sBIT;
+            png_set_invalid(png_ptr, info_ptr, PNG_INFO_sBIT);
             if (verbose)
                 pm_message("image gamma is %4.2f, "
                            "converted for display gamma of %4.2f",
@@ -635,20 +660,23 @@ setupGammaCorrection(png_struct * const
 
 
 static bool
-paletteHasPartialTransparency(png_info * const info_ptr) {
+paletteHasPartialTransparency(png_struct * const png_ptr, png_info * const info_ptr) {
 
     bool retval;
 
-    if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
-        if (info_ptr->valid & PNG_INFO_tRNS) {
+    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE) {
+        if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) {
             bool foundGray;
             unsigned int i;
+            int num_trans;
+            png_bytep trans_alpha;
+            png_get_tRNS(png_ptr, info_ptr, &trans_alpha, &num_trans, NULL);
             
             for (i = 0, foundGray = FALSE;
-                 i < info_ptr->num_trans && !foundGray;
+                 i < num_trans && !foundGray;
                  ++i) {
-                if (info_ptr->TRANS_ALPHA[i] != 0 &&
-                    info_ptr->TRANS_ALPHA[i] != maxval) {
+                if (trans_alpha[i] != 0 &&
+                    trans_alpha[i] != maxval) {
                     foundGray = TRUE;
                 }
             }
@@ -664,34 +692,44 @@ paletteHasPartialTransparency(png_info *
 
 
 static void
-getComponentSbitFg(png_info * const pngInfoP,
+getComponentSbitFg(png_struct * const pngP,
+                   png_info * const pngInfoP,
                    png_byte * const fgSbitP,
                    bool *     const notUniformP) {
 
-    if (pngInfoP->color_type == PNG_COLOR_TYPE_RGB ||
-        pngInfoP->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
-        pngInfoP->color_type == PNG_COLOR_TYPE_PALETTE) {
-        if (pngInfoP->sig_bit.red == pngInfoP->sig_bit.blue &&
-            pngInfoP->sig_bit.red == pngInfoP->sig_bit.green) {
+    int color_type = png_get_color_type(pngP, pngInfoP);
+    png_color_8p sig_bit;
+    png_get_sBIT(pngP, pngInfoP, &sig_bit);
+
+    if (color_type == PNG_COLOR_TYPE_RGB ||
+        color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+        color_type == PNG_COLOR_TYPE_PALETTE) {
+
+        if (sig_bit->red == sig_bit->blue &&
+            sig_bit->red == sig_bit->green) {
             *notUniformP = false;
-            *fgSbitP     = pngInfoP->sig_bit.red;
+            *fgSbitP     = sig_bit->red;
         } else
             *notUniformP = true;
     } else {
         /* It has only a gray channel so it's obviously uniform */
         *notUniformP = false;
-        *fgSbitP     = pngInfoP->sig_bit.gray;
+        *fgSbitP     = sig_bit->gray;
     }
 }
 
 
 
 static void
-getComponentSbit(png_info *          const pngInfoP,
+getComponentSbit(png_struct *        const pngP,
+                 png_info *          const pngInfoP,
                  enum alpha_handling const alphaHandling,
                  png_byte *          const componentSbitP,
                  bool *              const notUniformP) {
 
+    png_color_8p sig_bit;
+    png_get_sBIT(pngP, pngInfoP, &sig_bit);
+
     switch (alphaHandling) {
 
     case ALPHA_ONLY:
@@ -699,26 +737,26 @@ getComponentSbit(png_info *          con
            the alpha Sbit
         */
         *notUniformP = false;
-        *componentSbitP = pngInfoP->sig_bit.alpha;
+        *componentSbitP = sig_bit->alpha;
         break;
     case ALPHA_NONE:
     case ALPHA_MIX:
         /* We aren't going to produce an alpha channel, so we care only
            about the uniformity of the foreground channels.
         */
-        getComponentSbitFg(pngInfoP, componentSbitP, notUniformP);
+        getComponentSbitFg(pngP, pngInfoP, componentSbitP, notUniformP);
         break;
     case ALPHA_IN: {
         /* We care about both the foreground and the alpha */
         bool fgNotUniform;
         png_byte fgSbit;
         
-        getComponentSbitFg(pngInfoP, &fgSbit, &fgNotUniform);
+        getComponentSbitFg(pngP, pngInfoP, &fgSbit, &fgNotUniform);
 
         if (fgNotUniform)
             *notUniformP = true;
         else {
-            if (fgSbit == pngInfoP->sig_bit.alpha) {
+            if (fgSbit == sig_bit->alpha) {
                 *notUniformP    = false;
                 *componentSbitP = fgSbit;
             } else
@@ -731,7 +769,8 @@ getComponentSbit(png_info *          con
                  
 
 static void
-shiftPalette(png_info *   const pngInfoP,
+shiftPalette(png_struct * const pngP,
+             png_info *   const pngInfoP,
              unsigned int const shift) {
 /*----------------------------------------------------------------------------
    Shift every component of every color in the PNG palette right by
@@ -744,11 +783,14 @@ shiftPalette(png_info *   const pngInfoP
                  shift);
     else {
         unsigned int i;
-        
-        for (i = 0; i < pngInfoP->num_palette; ++i) {
-            pngInfoP->palette[i].red   >>= (8 - shift);
-            pngInfoP->palette[i].green >>= (8 - shift);
-            pngInfoP->palette[i].blue  >>= (8 - shift);
+        int num_palette;
+        png_colorp palette;
+        png_get_PLTE(pngP, pngInfoP, &palette, &num_palette);
+
+        for (i = 0; i < num_palette; ++i) {
+            palette[i].red   >>= (8 - shift);
+            palette[i].green >>= (8 - shift);
+            palette[i].blue  >>= (8 - shift);
         }
     }
 }
@@ -782,12 +824,12 @@ computeMaxvalFromSbit(png_struct *
            Meaningless if they aren't all the same (i.e. 'notUniform')
         */
 
-    getComponentSbit(pngInfoP, alphaHandling, &componentSigBit, &notUniform);
+    getComponentSbit(pngP, pngInfoP, alphaHandling, &componentSigBit, &notUniform);
 
     if (notUniform) {
         pm_message("This program cannot handle "
                    "different bit depths for color channels");
-        pm_message("writing file with %u bit resolution", pngInfoP->bit_depth);
+        pm_message("writing file with %u bit resolution", png_get_bit_depth(pngP, pngInfoP));
         *succeededP = false;
         *errorlevelP = PNMTOPNG_WARNING_LEVEL;
     } else if (componentSigBit > 15) {
@@ -797,22 +839,26 @@ computeMaxvalFromSbit(png_struct *
         *succeededP = false;
         *errorlevelP = PNMTOPNG_WARNING_LEVEL;
     } else {
+        int color_type = png_get_color_type(pngP, pngInfoP);
         if (alphaHandling == ALPHA_MIX &&
-            (pngInfoP->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
-             pngInfoP->color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
-             paletteHasPartialTransparency(pngInfoP)))
+            (color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+             color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
+             paletteHasPartialTransparency(pngP, pngInfoP)))
             *succeededP = false;
         else {
-            if (componentSigBit < pngInfoP->bit_depth) {
+            if (componentSigBit < png_get_bit_depth(pngP, pngInfoP)) {
                 pm_message("Image has fewer significant bits, "
                            "writing file with %u bits", componentSigBit);
                 *maxvalP = (1l << componentSigBit) - 1;
                 *succeededP = true;
 
-                if (pngInfoP->color_type == PNG_COLOR_TYPE_PALETTE)
-                    shiftPalette(pngInfoP, componentSigBit);
-                else
-                    png_set_shift(pngP, &pngInfoP->sig_bit);
+                if (color_type == PNG_COLOR_TYPE_PALETTE)
+                    shiftPalette(pngP, pngInfoP, componentSigBit);
+                else {
+                    png_color_8p sig_bit;
+		    png_get_sBIT(pngP, pngInfoP, &sig_bit);
+                    png_set_shift(pngP, sig_bit);
+		}
             } else
                 *succeededP = false;
         }
@@ -838,22 +884,23 @@ setupSignificantBits(png_struct *
 -----------------------------------------------------------------------------*/
     bool gotItFromSbit;
     
-    if (pngInfoP->valid & PNG_INFO_sBIT)
+    if (png_get_valid(pngP, pngInfoP, PNG_INFO_sBIT))
         computeMaxvalFromSbit(pngP, pngInfoP, alphaHandling,
                               maxvalP, &gotItFromSbit, errorlevelP);
     else
         gotItFromSbit = false;
 
     if (!gotItFromSbit) {
-        if (pngInfoP->color_type == PNG_COLOR_TYPE_PALETTE) {
+        int color_type = png_get_color_type(pngP, pngInfoP);
+        if (color_type == PNG_COLOR_TYPE_PALETTE) {
             if (alphaHandling == ALPHA_ONLY) {
-                if (pngInfoP->color_type == PNG_COLOR_TYPE_GRAY ||
-                    pngInfoP->color_type == PNG_COLOR_TYPE_RGB)
+                if (color_type == PNG_COLOR_TYPE_GRAY ||
+                    color_type == PNG_COLOR_TYPE_RGB)
                     /* The alpha mask will be all opaque, so maxval 1
                        is plenty
                     */
                     *maxvalP = 1;
-                else if (paletteHasPartialTransparency(pngInfoP))
+                else if (paletteHasPartialTransparency(pngP, pngInfoP))
                     /* Use same maxval as PNG transparency palette for
                        simplicity
                     */
@@ -865,7 +912,7 @@ setupSignificantBits(png_struct *
                 /* Use same maxval as PNG palette for simplicity */
                 *maxvalP = 255;
         } else {
-            *maxvalP = (1l << pngInfoP->bit_depth) - 1;
+            *maxvalP = (1l << png_get_bit_depth(pngP, pngInfoP)) - 1;
         }
     }
 }
@@ -873,22 +920,27 @@ setupSignificantBits(png_struct *
 
 
 static bool
-imageHasColor(png_info * const info_ptr) {
+imageHasColor(png_struct * const png_ptr, png_info * const info_ptr) {
 
     bool retval;
+    int color_type = png_get_color_type(png_ptr, info_ptr);
 
-    if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-        info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+    if (color_type == PNG_COLOR_TYPE_GRAY ||
+        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
 
         retval = FALSE;
-    else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
+    else if (color_type == PNG_COLOR_TYPE_PALETTE) {
         bool foundColor;
         unsigned int i;
+        int num_palette;
+        png_colorp palette;
+
+        png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);
             
         for (i = 0, foundColor = FALSE;
-             i < info_ptr->num_palette && !foundColor;
+             i < num_palette && !foundColor;
              ++i) {
-            if (iscolor(info_ptr->palette[i]))
+            if (iscolor(palette[i]))
                 foundColor = TRUE;
         }
         retval = foundColor;
@@ -901,7 +953,8 @@ imageHasColor(png_info * const info_ptr)
 
 
 static void
-determineOutputType(png_info *          const pngInfoP,
+determineOutputType(png_struct *        const pngP,
+                    png_info *          const pngInfoP,
                     enum alpha_handling const alphaHandling,
                     pngcolor            const bgColor,
                     xelval              const maxval,
@@ -916,7 +969,7 @@ determineOutputType(png_info *
     } else {            
         /* The output is a normal Netpbm image */
         bool const outputIsColor =
-            imageHasColor(pngInfoP) || !isGrayscale(bgColor);
+            imageHasColor(pngP, pngInfoP) || !isGrayscale(bgColor);
 
         if (alphaHandling == ALPHA_IN) {
             *formatP = PAM_FORMAT;
@@ -942,7 +995,8 @@ determineOutputType(png_info *
 
 
 static void
-getBackgroundColor(png_info *   const info_ptr,
+getBackgroundColor(png_struct * const png_ptr,
+                   png_info *   const info_ptr,
                    const char * const requestedColor,
                    float        const totalgamma,
                    xelval       const maxval,
@@ -964,19 +1018,26 @@ getBackgroundColor(png_info *   const in
         bgColorP->g = PPM_GETG(backcolor);
         bgColorP->b = PPM_GETB(backcolor);
 
-    } else if (info_ptr->valid & PNG_INFO_bKGD) {
+    } else if (png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD)) {
+        png_color_16p background;
+        png_get_bKGD(png_ptr, info_ptr, &background);
         /* didn't manage to get libpng to work (bugs?) concerning background
            processing, therefore we do our own.
         */
-        switch (info_ptr->color_type) {
+        switch (png_get_color_type(png_ptr, info_ptr)) {
         case PNG_COLOR_TYPE_GRAY:
         case PNG_COLOR_TYPE_GRAY_ALPHA:
             bgColorP->r = bgColorP->g = bgColorP->b = 
-                gamma_correct(info_ptr->background.gray, totalgamma);
+                gamma_correct(background->gray, totalgamma);
             break;
         case PNG_COLOR_TYPE_PALETTE: {
-            png_color const rawBgcolor = 
-                info_ptr->palette[info_ptr->background.index];
+            png_color rawBgcolor;
+            png_colorp palette;
+            int num_palette;
+
+            png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);
+            rawBgcolor = 
+                palette[background->index];
             bgColorP->r = gamma_correct(rawBgcolor.red, totalgamma);
             bgColorP->g = gamma_correct(rawBgcolor.green, totalgamma);
             bgColorP->b = gamma_correct(rawBgcolor.blue, totalgamma);
@@ -984,7 +1045,7 @@ getBackgroundColor(png_info *   const in
         break;
         case PNG_COLOR_TYPE_RGB:
         case PNG_COLOR_TYPE_RGB_ALPHA: {
-            png_color_16 const rawBgcolor = info_ptr->background;
+            png_color_16 const rawBgcolor = *background;
             
             bgColorP->r = gamma_correct(rawBgcolor.red,   totalgamma);
             bgColorP->g = gamma_correct(rawBgcolor.green, totalgamma);
@@ -999,13 +1060,14 @@ getBackgroundColor(png_info *   const in
 
 
 
-#define GET_PNG_VAL(p) get_png_val(&(p), pngInfoP->bit_depth)
+#define GET_PNG_VAL(p) get_png_val(&(p), png_get_bit_depth(pngP, pngInfoP))
 
 
 
 static void
 makeTupleRow(const struct pam *  const pamP,
              const tuple *       const tuplerow,
+	     png_struct *        const pngP,
              png_info *          const pngInfoP,
              const png_byte *    const pngRasterRow,
              pngcolor            const bgColor,
@@ -1016,13 +1078,13 @@ makeTupleRow(const struct pam *  const p
     unsigned int col;
 
     pngPixelP = &pngRasterRow[0];  /* initial value */
-    for (col = 0; col < pngInfoP->width; ++col) {
-        switch (pngInfoP->color_type) {
+    for (col = 0; col < png_get_image_width(pngP, pngInfoP); ++col) {
+        switch (png_get_color_type(pngP, pngInfoP)) {
         case PNG_COLOR_TYPE_GRAY: {
             pngcolor fgColor;
             fgColor.r = fgColor.g = fgColor.b = GET_PNG_VAL(pngPixelP);
             setTuple(pamP, tuplerow[col], fgColor, bgColor, alphaHandling,
-                   isTransparentColor(fgColor, pngInfoP, totalgamma) ?
+                   isTransparentColor(fgColor, pngP, pngInfoP, totalgamma) ?
                    0 : maxval);
         }
         break;
@@ -1040,18 +1102,26 @@ makeTupleRow(const struct pam *  const p
 
         case PNG_COLOR_TYPE_PALETTE: {
             png_uint_16 const index        = GET_PNG_VAL(pngPixelP);
-            png_color   const paletteColor = pngInfoP->palette[index];
-
+            png_color   paletteColor;
+            bool        transValid = png_get_valid(pngP, pngInfoP, PNG_INFO_tRNS);
+            png_bytep trans_alpha;
+            int num_trans, num_palette;
+            png_colorp palette;
             pngcolor fgColor;
 
+            png_get_PLTE(pngP, pngInfoP, &palette, &num_palette);
+	    paletteColor = palette[index];
+
             fgColor.r = paletteColor.red;
             fgColor.g = paletteColor.green;
             fgColor.b = paletteColor.blue;
 
+	    if (transValid)
+	        png_get_tRNS(pngP, pngInfoP, &trans_alpha, &num_trans, NULL);
             setTuple(pamP, tuplerow[col], fgColor, bgColor, alphaHandling,
-                     (pngInfoP->valid & PNG_INFO_tRNS) &&
-                     index < pngInfoP->num_trans ?
-                     pngInfoP->TRANS_ALPHA[index] : maxval);
+                     transValid &&
+                     index < num_trans ?
+                     trans_alpha[index] : maxval);
         }
         break;
                 
@@ -1062,7 +1132,7 @@ makeTupleRow(const struct pam *  const p
             fgColor.g = GET_PNG_VAL(pngPixelP);
             fgColor.b = GET_PNG_VAL(pngPixelP);
             setTuple(pamP, tuplerow[col], fgColor, bgColor, alphaHandling,
-                     isTransparentColor(fgColor, pngInfoP, totalgamma) ?
+                     isTransparentColor(fgColor, pngP, pngInfoP, totalgamma) ?
                      0 : maxval);
         }
         break;
@@ -1081,7 +1151,7 @@ makeTupleRow(const struct pam *  const p
         break;
 
         default:
-            pm_error("unknown PNG color type: %d", pngInfoP->color_type);
+            pm_error("unknown PNG color type: %d", png_get_color_type(pngP, pngInfoP));
         }
     }
 }
@@ -1115,6 +1185,7 @@ reportOutputFormat(const struct pam * co
 
 static void
 writeNetpbm(struct pam *        const pamP,
+            png_struct *        const pngP,
             png_info *          const pngInfoP,
             png_byte **         const pngRaster,
             pngcolor            const bgColor,
@@ -1141,8 +1212,8 @@ writeNetpbm(struct pam *        const pa
 
     tuplerow = pnm_allocpamrow(pamP);
 
-    for (row = 0; row < pngInfoP->height; ++row) {
-        makeTupleRow(pamP, tuplerow, pngInfoP, pngRaster[row], bgColor,
+    for (row = 0; row < png_get_image_height(pngP, pngInfoP); ++row) {
+        makeTupleRow(pamP, tuplerow, pngP, pngInfoP, pngRaster[row], bgColor,
                      alphaHandling, totalgamma);
 
         pnm_writepamrow(pamP, tuplerow);
@@ -1186,9 +1257,9 @@ convertpng(FILE *             const ifp,
     png_set_sig_bytes (png_ptr, SIG_CHECK_SIZE);
     png_read_info (png_ptr, info_ptr);
 
-    allocPngRaster(info_ptr, &png_image);
+    allocPngRaster(png_ptr, info_ptr, &png_image);
 
-    if (info_ptr->bit_depth < 8)
+    if (png_get_bit_depth(png_ptr, info_ptr) < 8)
         png_set_packing (png_ptr);
 
     setupGammaCorrection(png_ptr, info_ptr, cmdline.gamma, &totalgamma);
@@ -1196,7 +1267,7 @@ convertpng(FILE *             const ifp,
     setupSignificantBits(png_ptr, info_ptr, cmdline.alpha,
                          &maxval, errorlevelP);
 
-    getBackgroundColor(info_ptr, cmdline.background, totalgamma, maxval,
+    getBackgroundColor(png_ptr, info_ptr, cmdline.background, totalgamma, maxval,
                        &bgColor);
 
     png_read_image(png_ptr, png_image);
@@ -1207,16 +1278,19 @@ convertpng(FILE *             const ifp,
            completes.  That's because it comes from chunks that are at the
            end of the stream.
         */
-        dump_png_info(info_ptr);
+        dump_png_info(png_ptr, info_ptr);
 
     if (cmdline.time)
-        show_time(info_ptr);
+        show_time(png_ptr, info_ptr);
     if (tfp)
-        save_text(info_ptr, tfp);
+        save_text(png_ptr, info_ptr, tfp);
+
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_pHYs)) {
+        float r;
+        png_uint_32 x_pixels_per_unit, y_pixels_per_unit;
 
-    if (info_ptr->valid & PNG_INFO_pHYs) {
-        float const r =
-            (float)info_ptr->x_pixels_per_unit / info_ptr->y_pixels_per_unit;
+        png_get_pHYs(png_ptr, info_ptr, &x_pixels_per_unit, &y_pixels_per_unit, NULL);
+        r = (float)x_pixels_per_unit / y_pixels_per_unit;
         if (r != 1.0) {
             pm_message ("warning - non-square pixels; "
                         "to fix do a 'pamscale -%cscale %g'",
@@ -1230,18 +1304,18 @@ convertpng(FILE *             const ifp,
     pam.len         = PAM_STRUCT_SIZE(tuple_type);
     pam.file        = stdout;
     pam.plainformat = 0;
-    pam.height      = info_ptr->height;
-    pam.width       = info_ptr->width;
+    pam.height      = png_get_image_height(png_ptr, info_ptr);
+    pam.width       = png_get_image_width(png_ptr, info_ptr);
     pam.maxval      = maxval;
 
-    determineOutputType(info_ptr, cmdline.alpha, bgColor, maxval,
+    determineOutputType(png_ptr, info_ptr, cmdline.alpha, bgColor, maxval,
                         &pam.format, &pam.depth, pam.tuple_type);
 
-    writeNetpbm(&pam, info_ptr, png_image, bgColor, cmdline.alpha, totalgamma);
+    writeNetpbm(&pam, png_ptr, info_ptr, png_image, bgColor, cmdline.alpha, totalgamma);
 
     fflush(stdout);
 
-    freePngRaster(png_image, info_ptr);
+    freePngRaster(png_image, png_ptr, info_ptr);
 
     png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
 }
